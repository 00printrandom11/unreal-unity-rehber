import fs from 'fs';
import { guideData } from './guideData.js';

function esc(s){return s.replace(/\\/g,'\\\\').replace(/'/g,"\\'").replace(/\n/g,'\\n').replace(/\r/g,'');}
const ev=s=>`<span class="ev">${s}</span>`;
const nd=s=>`<span class="nd">${s}</span>`;
const fn=s=>`<span class="fn">${s}</span>`;
const vr=s=>`<span class="vr">${s}</span>`;
const cm=s=>`<span class="cm">${s}</span>`;

function g(id,title,diff,desc,steps,bpFlow,tips,warns){
  return {
    id, title, difficulty:diff, description:desc,
    steps: steps.map(s=>({title:s[0],content:s[1]})),
    blueprintFlow: (bpFlow||[]).map(b=>({title:b.t,tags:(b.tags||[]).map(t=>({type:t[0],label:t[1]})),desc:b.d,flow:b.f,variables:b.v||[],events:b.e||[]})),
    tips: tips||[], warnings: warns||[]
  };
}

const batch = [
// ====== KARAKTER & HAREKET ======
{cat:'Karakter & Hareket',guide:g('bp-adv-sprint','Gelişmiş Sprint Sistemi (Stamina)','Orta',
  'Stamina bazlı koşma sistemi. Koşarken stamina azalır, durduğunda belirli bir gecikme sonrası yenilenir. FOV değişimi ve kamera efektleri ile desteklenir.',
  [['Stamina Değişkenleri',`Character BP'ye şu değişkenleri ekleyin: MaxStamina (Float, 100), CurrentStamina (Float, 100), DrainRate (Float, 20), RegenRate (Float, 15), RegenDelay (Float, 2.0), bIsSprinting (Boolean), NormalSpeed (Float, 600), SprintSpeed (Float, 900). CurrentStamina başlangıçta MaxStamina'ya eşit olmalıdır.`],
   ['Sprint Başlatma',`Enhanced Input Action "IA_Sprint" oluşturun (Shift tuşu). Started event'inde: Branch ile CurrentStamina > 10 kontrolü yapın. True ise bIsSprinting = True ayarlayın, Character Movement Component'ın Max Walk Speed değerini SprintSpeed (900) olarak set edin. Bir Timeline node ile kameranın FOV değerini 90'dan 100'e 0.3 saniyede yükseltin. Sprint başlangıcında hafif bir Camera Shake ekleyebilirsiniz.`],
   ['Stamina Tüketimi (Tick)',`Event Tick içinde bIsSprinting kontrolü yapın. True ise: CurrentStamina -= DrainRate * DeltaTime hesaplayın. Clamp node ile 0 ile MaxStamina arasında sınırlayın. Sonucu CurrentStamina'ya geri yazın. Her tick'te HUD'daki stamina barını güncelleyin. CurrentStamina 0'a düşerse StopSprint fonksiyonunu çağırın.`],
   ['Sprint Durdurma',`StopSprint fonksiyonu: bIsSprinting = False, Max Walk Speed = NormalSpeed (600), FOV Timeline'ını Reverse'den oynatın. Set Timer by Event ile RegenDelay (2 saniye) sonra StartRegen fonksiyonunu çağırın. Bu gecikme oyuncunun sprint'ten hemen sonra stamina kazanmasını engeller.`],
   ['Stamina Yenilenmesi',`StartRegen fonksiyonu: bIsRegening = True. Event Tick'te bIsRegening True ise: CurrentStamina += RegenRate * DeltaTime. CurrentStamina >= MaxStamina olduğunda bIsRegening = False yapın ve timer'ı temizleyin. Sprint sırasında regen durmalıdır - bIsSprinting True olduğunda regen timer'ını iptal edin.`]],
  [{t:'Sprint & Stamina',tags:[['fn','SetMaxWalkSpeed'],['ev','IA_Sprint'],['class','CharacterMovement']],
    d:'Stamina bazlı koşma sistemi. Sprint başlatma, stamina tüketimi, regen ve FOV değişimi.',
    f:ev('IA_Sprint Started')+`\n  │\n  └──→ ${nd('Branch')} (CurrentStamina > 10)\n        │ True\n        ├──→ bIsSprinting = True\n        ├──→ ${fn('Set Max Walk Speed')} → 900\n        └──→ ${fn('Play Timeline')} FOV: 90→100 (0.3s)\n\n${ev('Event Tick')}\n  │\n  ├──→ ${nd('Branch')} (bIsSprinting)\n  │     ├──→ Stamina -= DrainRate × DT\n  │     ├──→ ${nd('Clamp')} (0, MaxStamina)\n  │     └──→ ${nd('Branch')} (Stamina <= 0) → ${fn('StopSprint')}\n  │\n  └──→ ${nd('Branch')} (bIsRegening)\n        └──→ Stamina += RegenRate × DT\n\n${fn('StopSprint')}\n  ├──→ bIsSprinting = False\n  ├──→ ${fn('Set Max Walk Speed')} → 600\n  ├──→ ${fn('Reverse Timeline')} FOV\n  └──→ ${nd('Set Timer')} 2s → StartRegen`,
    v:['MaxStamina: 100','CurrentStamina: Float','DrainRate: 20/s','RegenRate: 15/s','bIsSprinting: Bool','SprintSpeed: 900'],
    e:['IA_Sprint Started','IA_Sprint Completed','Event Tick']}],
  ['Sprint sırasında ayak sesi frekansını artırarak koşma hissi güçlendirin.','Stamina barını HUD\'a eklerken renk geçişi kullanın: yeşil→sarı→kırmızı.','Sprint Camera Shake ekleyerek immersion artırın.'],
  ['Tick\'te sürekli Branch çalıştırmak yüksek actor sayısında performansı düşürebilir, Timer alternatif düşünün.','Sprint hızını 1200 üzerine çıkarmayın, collision tunneling oluşabilir.'])},

{cat:'Karakter & Hareket',guide:g('bp-adv-crouch','Gelişmiş Eğilme Sistemi','Başlangıç',
  'Karakter eğilme sistemi. Capsule boyutu küçülür, kamera alçalır, hareket hızı düşer. Üzerinde engel varsa kalkamaz kontrolü içerir.',
  [['Değişkenler',`Character Movement Component'ta Crouch özelliğini etkinleştirin: Details panelinde "Can Crouch" = True. Crouched Half Height varsayılan 44'tür. Normal Half Height 88'dir. Ek olarak CrouchSpeed (Float, 300) ve NormalSpeed (Float, 600) değişkenleri tanımlayın.`],
   ['Eğilme Input',`IA_Crouch action oluşturun (C tuşu). Started event'inde Crouch fonksiyonunu, Completed event'inde UnCrouch fonksiyonunu çağırın. Toggle yapmak isterseniz: bir Boolean bWantsCrouch değişkeni ile Flip Flop kullanın - her basışta Crouch/UnCrouch arasında geçiş.`],
   ['Kamera Geçişi',`Ani capsule değişimi kamerayı sarsabilir. Spring Arm'ın Socket Offset Z değerini Timeline ile yumuşak değiştirin. Ayakta: Z=70, Eğilme: Z=30. 0.2 saniyelik Ease In/Out eğrisi kullanın. Bu sayede kamera yumuşak şekilde alçalır.`],
   ['Engel Kontrolü',`UnCrouch öncesinde üstte engel kontrolü yapın: Capsule'ün üstünden Sphere Trace yukarı doğru atın. Hit varsa kalkamaz - oyuncuya "Kalkılamaz" mesajı gösterin veya eğik kalmaya devam edin. Hit yoksa normal UnCrouch çağırın.`],
   ['Hız Ayarı',`Eğilme sırasında Max Walk Speed'i CrouchSpeed (300) yapın. Kalktığında NormalSpeed'e (600) geri döndürün. Eğilme + hareket sırasında farklı animasyon (Crouch Walk) oynatılmalıdır - Anim Blueprint'te bIsCrouching Boolean'ı ile kontrol edin.`]],
  [{t:'Crouch Sistemi',tags:[['fn','Crouch'],['fn','UnCrouch'],['class','CharacterMovement']],
    d:'Eğilme, kalkma, engel kontrolü ve kamera yumuşatma.',
    f:ev('IA_Crouch Started')+`\n  │\n  ├──→ ${fn('Crouch')}\n  ├──→ ${fn('Set Max Walk Speed')} → 300\n  └──→ ${fn('Play Timeline')} CamOffset: Z 70→30 (0.2s)\n\n${ev('IA_Crouch Completed')}\n  │\n  ├──→ ${fn('Sphere Trace Up')} (Head Check)\n  └──→ ${nd('Branch')} (Hit?)\n        │ False (engel yok)\n        ├──→ ${fn('UnCrouch')}\n        ├──→ ${fn('Set Max Walk Speed')} → 600\n        └──→ ${fn('Reverse Timeline')} CamOffset\n        │ True (engel var)\n        └──→ ${cm('Eğilmeye devam et')}`,
    v:['bIsCrouching: Bool','CrouchSpeed: 300','CrouchedHalfHeight: 44'],
    e:['IA_Crouch Started','IA_Crouch Completed']}],
  ['Toggle crouch için Flip Flop node kullanın.','Eğilme sırasında crosshair\'ı daraltarak nişan bonusu hissi verin.'],
  ['Sphere Trace yarıçapını capsule yarıçapıyla eşleştirin, aksi halde dar alanlardan kalkabilir.'])},

{cat:'Karakter & Hareket',guide:g('bp-wall-climb','Duvar Tırmanma Sistemi','İleri',
  'Dikey yüzeylere tutunma ve tırmanma. İleri trace ile duvar algılama, yukarı trace ile kenar bulma, input ile yukarı/aşağı/sağa/sola hareket.',
  [['Duvar Algılama',`Karakterin önünden sürekli Line Trace atın (Tick veya Timer). Trace mesafesi 80-100 birim. Hit edilen yüzeyin normali kontrol edin: Normal.Z -0.1 ile 0.1 arasıysa dikeydir (tırmanılabilir). Surface Type veya Actor Tag ile de filtreleyebilirsiniz ("Climbable" tag'i).`],
   ['Tutunma Başlatma',`Tırmanılabilir yüzeye yakınken ve havadayken IA_Grab input'u ile tutunma başlatın. Movement Mode'u Flying yapın. Gravity Scale'i 0 yapın. Karakteri duvara yapıştırın: Set Actor Location ile duvar normal yönünde offset (20 birim duvardan uzak). Set Actor Rotation ile duvara bakar pozisyona getirin.`],
   ['Tırmanma Hareketi',`Tutunma sırasında IA_Move input'u ile yukarı/aşağı/sağa/sola hareket sağlayın. Hareket hızı ClimbSpeed (200) olsun. Her hareket adımında tekrar Line Trace ile duvarın devam edip etmediğini kontrol edin. Duvar bitiyorsa hareketi durdurun. Animasyon: Climb Up, Climb Left, Climb Right, Climb Idle.`],
   ['Kenar Çıkış (Mantle)',`Tırmanma sırasında yukarıya trace atın. Trace'in hit etmemesi duvarın bittiği anlamına gelir (kenar). Bu noktada: Movement Mode'u Walking'e çevirin, Play Montage ile Climb_Over animasyonu oynatın, Root Motion ile karakteri kenarın üstüne taşıyın.`],
   ['Bırakma ve Düşme',`IA_Grab'in Completed event'inde veya belirli bir tuşla (örneğin Space) duvardan bırakma: Movement Mode'u Falling yapın, Gravity Scale'i 1'e döndürün. Opsiyonel: bırakma sırasında Launch Character ile hafifçe geriye fırlatın. Stamina sistemiyle entegre edebilirsiniz - tırmanma stamina harcar.`]],
  [{t:'Wall Climb',tags:[['fn','LineTrace'],['fn','SetMovementMode'],['fn','SetActorLocation']],
    d:'Duvar algılama, tutunma, hareket ve kenar çıkışı.',
    f:ev('Event Tick')+` ${cm('Duvar Algılama')}\n  │\n  ├──→ ${fn('Line Trace')} Forward (80 units)\n  └──→ ${nd('Branch')} (Hit + Normal.Z ≈ 0 + Tag=Climbable)\n        └──→ bCanClimb = True\n\n${ev('IA_Grab Started')} ${cm('(bCanClimb + InAir)')}\n  │\n  ├──→ ${fn('Set Movement Mode')} Flying\n  ├──→ ${fn('Set Gravity Scale')} 0\n  ├──→ ${fn('Set Actor Rotation')} Face Wall\n  └──→ bIsClimbing = True\n\n${ev('IA_Move (While Climbing)')}\n  │\n  ├──→ ${fn('Add Movement Input')} (Up/Right × ClimbSpeed)\n  ├──→ ${fn('Line Trace')} Forward ${cm('(duvar devam kontrolü)')}\n  └──→ ${fn('Line Trace')} Up ${cm('(kenar kontrolü)')}\n        └──→ ${nd('Branch')} (No Hit = Kenar!)\n              ├──→ ${fn('Play Montage')} ClimbOver\n              └──→ ${fn('Set Movement Mode')} Walking\n\n${ev('IA_Grab Completed')} ${cm('(Bırakma)')}\n  ├──→ ${fn('Set Movement Mode')} Falling\n  └──→ ${fn('Set Gravity Scale')} 1.0`,
    v:['bCanClimb: Bool','bIsClimbing: Bool','ClimbSpeed: 200','WallNormal: Vector'],
    e:['Event Tick','IA_Grab Started','IA_Grab Completed','IA_Move']}],
  ['Tırmanma sırasında stamina tüketimi ekleyerek zorluk katın.','Duvarın tırmanılabilir kısımlarını Material veya Tag ile işaretleyin.','Tırmanma animasyonları arasında Blend Space kullanarak yumuşak geçiş sağlayın.'],
  ['Movement Mode değişikliklerinde animasyon geçişlerini test edin, aksi halde T-pose oluşabilir.','Trace mesafesini çok uzun yaparsanız uzaktaki duvarlara yapışma oluşur.'])},

{cat:'Karakter & Hareket',guide:g('bp-zipline','Zipline Mekaniği','Orta',
  'İki nokta arasında gerili ip üzerinde kayma. Spline Component ile hat tanımlama, oyuncunun hatta bağlanması ve kayma fiziği.',
  [['Zipline Actor',`BP_Zipline actor oluşturun. İçine Spline Component ekleyin. Başlangıç ve bitiş noktalarını editörde ayarlayın. Opsiyonel: Static Mesh Component ile ip/kablo görseli (Spline Mesh). Başlangıç noktasına Sphere Collision ekleyin (tutunma alanı).`],
   ['Bağlanma',`Oyuncu Sphere Collision'a girdiğinde ve IA_Interact bastığında: Oyuncunun Movement Mode'unu Flying yapın. Oyuncuyu Spline üzerindeki en yakın noktaya (Find Input Key Closest to World Location) konumlandırın. Attach Actor to Component ile Spline'a bağlayın veya manual takip yapın.`],
   ['Kayma Hareketi',`Event Tick'te: SplineProgress değerini her frame artırın (Speed * DeltaTime / SplineLength). Get Location at Distance Along Spline ile yeni pozisyonu hesaplayın. Get Rotation at Distance Along Spline ile rotasyonu ayarlayın. Set Actor Location + Rotation ile oyuncuyu güncelleyin.`],
   ['Bitiş ve Ayrılma',`SplineProgress >= 1.0 olduğunda veya oyuncu Jump tuşuna bastığında: Movement Mode'u Walking/Falling yapın. Detach edin. Jump ile ayrılmada Launch Character ile ileri + yukarı fırlatın. Bitiş noktasından inerken de yumuşak geçiş için kısa bir Launch yapın.`],
   ['Görsel ve Ses',`Kayma sırasında: Niagara ile rüzgar partikülü, kablo üzerinde kıvılcım efekti. Looping ses efekti (metal sürtünme). Hız arttıkça ses pitch'i yükselir. Kamera: Spring Arm'ı biraz uzaklaştırarak hız hissi verin.`]],
  [{t:'Zipline',tags:[['class','SplineComponent'],['fn','GetLocationAtDistanceAlongSpline']],
    d:'Spline bazlı zipline kayma sistemi.',
    f:ev('IA_Interact + In Zipline Zone')+`\n  │\n  ├──→ ${fn('Set Movement Mode')} Flying\n  ├──→ ${fn('Find Closest Point on Spline')}\n  ├──→ SplineProgress = 0\n  └──→ bOnZipline = True\n\n${ev('Event Tick')} ${cm('(bOnZipline)')}\n  │\n  ├──→ SplineProgress += Speed × DT / SplineLength\n  ├──→ Pos = ${fn('Get Location at Distance')} (Progress × Length)\n  ├──→ Rot = ${fn('Get Rotation at Distance')} (Progress × Length)\n  ├──→ ${fn('Set Actor Location')} (Pos + Offset)\n  ├──→ ${fn('Set Actor Rotation')} (Rot)\n  └──→ ${nd('Branch')} (Progress >= 1.0)\n        └──→ ${fn('Detach and Land')}\n\n${ev('IA_Jump (While On Zipline)')}\n  ├──→ bOnZipline = False\n  ├──→ ${fn('Set Movement Mode')} Falling\n  └──→ ${fn('Launch Character')} Forward+Up`,
    v:['SplineProgress: Float','ZiplineSpeed: 800','bOnZipline: Bool'],
    e:['IA_Interact','Event Tick','IA_Jump']}],
  ['Spline noktalarını editörde ayarlayarak eğim ve eğri verin.','Birden fazla zipline\'ı aynı BP ile farklı spline uzunluklarında kullanın.'],
  ['Spline üzerinde hareket hızını sabit tutarsanız yokuş yukarı ve aşağı aynı hızda olur - yerçekimi simülasyonu ekleyin.'])},

{cat:'Karakter & Hareket',guide:g('bp-swimming','Yüzme Sistemi','Orta',
  'Su hacmi içinde yüzme mekaniği. Hız azalması, kamera su altı efekti, oksijen sistemi ve yüzme animasyonları.',
  [['Su Hacmi (Water Volume)',`BP_WaterVolume actor oluşturun. Box Collision ile su alanını tanımlayın. Su yüzeyi için bir Plane mesh veya Water plugin kullanın. Physics Volume component ekleyin: bWaterVolume = True, FluidFriction ayarlayın. Volume içine giren aktöre Swimming modunu zorlayın.`],
   ['Mod Değişikliği',`On Begin Overlap event'inde: Cast to Character, ardından Set Movement Mode = Swimming yapın. Character Movement Component'ın Swimming ayarlarını kullanın: Max Swim Speed (300), Buoyancy (1.0). On End Overlap'te Movement Mode'u Walking'e döndürün.`],
   ['Yüzme Kontrolü',`Swimming modunda WASD ile yatay hareket, Space ile yukarı yüzme, Ctrl ile dalma. IA_Move için: Add Movement Input ile yatay, IA_SwimUp ve IA_SwimDown ile dikey hareket ekleyin. Kamera kontrolü mouse ile - sualtında serbest bakış.`],
   ['Oksijen Sistemi',`MaxOxygen (Float, 100), CurrentOxygen değişkenleri. Su yüzeyinin altındayken (Head Z < WaterSurface Z): OxygenDrainRate ile azaltın. Yüzeyde ise hızla doldurun. Oksijen 0'a düşünce: saniyede 10 hasar verin. HUD'da oksijen barı gösterin.`],
   ['Görsel Efektler',`Sualtı Post Process Volume: mavi renk tonu, bulanıklık, distortion. Kamera su altına geçince aktif edin. Su yüzeyi geçişinde splash partikülü ve ses efekti. Yüzme sırasında kabarcık partikülü. Su altında sesleri boğuk yapın (Low Pass Filter).`]],
  [{t:'Swimming System',tags:[['class','PhysicsVolume'],['fn','SetMovementMode']],
    d:'Su hacmi, yüzme modu, oksijen ve sualtı efektleri.',
    f:ev('On Begin Overlap (WaterVolume)')+`\n  │\n  ├──→ ${fn('Cast to Character')}\n  ├──→ ${fn('Set Movement Mode')} Swimming\n  ├──→ bInWater = True\n  └──→ ${fn('Spawn Emitter')} SplashVFX\n\n${ev('Event Tick')} ${cm('(bInWater)')}\n  │\n  ├──→ ${nd('Branch')} (HeadZ < SurfaceZ)\n  │     │ True ${cm('(Su altında)')}\n  │     ├──→ Oxygen -= DrainRate × DT\n  │     ├──→ ${nd('Branch')} (Oxygen <= 0)\n  │     │     └──→ ${fn('Apply Damage')} 10/s\n  │     └──→ Enable Underwater PP\n  │     │ False ${cm('(Yüzeyde)')}\n  │     ├──→ Oxygen += RegenRate × DT\n  │     └──→ Disable Underwater PP\n  └──→ Update Oxygen UI\n\n${ev('On End Overlap')}\n  ├──→ ${fn('Set Movement Mode')} Walking\n  └──→ bInWater = False`,
    v:['MaxOxygen: 100','CurrentOxygen: Float','OxygenDrainRate: 8/s','bInWater: Bool'],
    e:['On Begin Overlap','On End Overlap','Event Tick']}],
  ['Water plugin (UE5) ile gerçekçi su yüzeyi oluşturabilirsiniz.','Sualtı sesleri için Audio Volume ile reverb ekleyin.','Yüzme animasyonları için Blend Space kullanın: hız ve yön parametreleri.'],
  ['Physics Volume olmadan Swimming mode düzgün çalışmaz.','Oksijen sistemini test ederken hasar ile ölüm mekanizmasını da bağlayın.'])},

{cat:'Karakter & Hareket',guide:g('bp-grapple-hook','Kanca (Grapple Hook) Sistemi','İleri',
  'Hedef noktaya kanca atıp çekme mekaniği. Cable Component ile görsel, fizik bazlı hareket ve tutunma noktaları.',
  [['Hedef Belirleme',`Kanca atılabilecek noktaları sahneye yerleştirin (BP_GrapplePoint actor'ları, belirgin ikon veya mesh ile). Oyuncu nişan aldığında Sphere Trace veya Line Trace ile en yakın GrapplePoint'i bulun. Menzil kontrolü (MaxGrappleRange, örn: 2000 birim). Geçerli hedef bulunursa UI'da ikon gösterin.`],
   ['Kanca Fırlatma',`IA_Grapple input'unda: Cable Component spawn edin (başlangıç: karakter eli, bitiş: hedef nokta). Kanca "uçuş" animasyonu için Timeline kullanın: Cable'ın End Location'ını 0.3s içinde hedef noktaya doğru ilerletin. Ulaşınca kanca sabitlenir.`],
   ['Çekme Mekaniği',`Kanca sabitlendikten sonra oyuncuyu hedefe doğru çekin. İki yöntem: 1) Launch Character ile sabit hızda hedefe fırlatma. 2) Tick'te oyuncuyu hedefe doğru Lerp ile çekme. İkinci yöntem daha kontrollü. Çekme sırasında Movement Mode = Flying, Gravity = 0. Hedefe yaklaşınca (mesafe < 100) çekmeyi bitirin.`],
   ['Sallanma (Swing) Modu',`Alternatif: kanca sabitlendikten sonra sarkaç fiziği. Physics Constraint veya manual hesaplama ile sallanma. Oyuncunun pozisyonunu kanca noktası etrafında döndürün. Input ile sallanma yönü ve hızı kontrolü. Bırakma anında momentum korunur - Launch Character ile fırlatın.`],
   ['Temizlik',`Çekme bitince veya oyuncu bıraktığında: Cable Component'ı yok edin, Movement Mode'u Walking/Falling'e döndürün, Gravity Scale'i 1'e geri alın. Cooldown timer ekleyerek ardarda kanca atımını engelleyin. Kanca animasyonu: el uzatma ve geri çekme montage.`]],
  [{t:'Grapple Hook',tags:[['class','CableComponent'],['fn','LaunchCharacter'],['fn','LineTrace']],
    d:'Hedef bulma, kanca atma, çekme ve sallanma.',
    f:ev('IA_Grapple Started')+`\n  │\n  ├──→ ${fn('Sphere Trace')} (GrappleRange: 2000)\n  ├──→ ${nd('Branch')} (Hit GrapplePoint?)\n  │     │ True\n  │     ├──→ ${fn('Spawn Cable Component')}\n  │     ├──→ ${fn('Play Timeline')} CableFly (0.3s)\n  │     │     └──→ Cable.EndLocation → Target\n  │     └──→ On Timeline End:\n  │           ├──→ ${fn('Set Movement Mode')} Flying\n  │           ├──→ ${fn('Set Gravity')} 0\n  │           └──→ bIsGrappling = True\n  │\n  └──→ ${nd('Branch')} (False) → ${cm('Hedef yok')}\n\n${ev('Event Tick')} ${cm('(bIsGrappling)')}\n  │\n  ├──→ Dir = Target - Player (Normalize)\n  ├──→ ${fn('Add Movement Input')} (Dir × GrappleSpeed)\n  └──→ ${nd('Branch')} (Distance < 100)\n        └──→ ${fn('StopGrapple')}\n\n${fn('StopGrapple')}\n  ├──→ Destroy Cable\n  ├──→ ${fn('Set Movement Mode')} Falling\n  ├──→ ${fn('Set Gravity')} 1.0\n  └──→ ${nd('Set Timer')} Cooldown 2s`,
    v:['GrappleRange: 2000','GrappleSpeed: 1500','bIsGrappling: Bool','GrappleTarget: Vector','CooldownTime: 2.0'],
    e:['IA_Grapple Started','Event Tick']}],
  ['Grapple Point\'lere Niagara efekti ekleyerek oyuncunun görmesini kolaylaştırın.','Sallanma sırasında kamera FOV\'unu artırarak hız hissi verin.','Cable Component\'ın rengini ve kalınlığını ayarlayarak estetik iyileştirin.'],
  ['Grapple sırasında duvara çarpmayı kontrol edin, aksi halde oyuncu sıkışabilir.','Çok hızlı çekme physics hatalarına yol açabilir, hızı sınırlayın.'])},

{cat:'Karakter & Hareket',guide:g('bp-dodge-roll','Dodge Roll (Takla) Sistemi','Orta',
  'Düşman saldırılarından kaçınmak için yöne doğru takla. I-frame (invincibility frame) ile hasar yok sayma, animasyon ve cooldown.',
  [['Input ve Yön',`IA_Dodge action oluşturun (Alt tuşu veya çift yön tuşu). Tetiklendiğinde hareket yönünü alın: Get Last Movement Input Vector ile son hareket yönü. Eğer oyuncu durmaktaysa, karakterin Forward vektörünü kullanın. Bu yön DodgeDirection olacak.`],
   ['Takla Hareketi',`Root Motion kullanımı önerilir: Dodge_Forward, Dodge_Back, Dodge_Left, Dodge_Right montage\'ları oluşturun. Yöne göre doğru montage\'ı Play Montage ile oynatın. Root Motion olmadan: Launch Character ile DodgeDirection * DodgeForce (800) kuvveti uygulayın. 0.4s sonra hareket durur.`],
   ['I-Frame (Dokunulmazlık)',`Takla sırasında hasarı yok saymak için: Dodge başlangıcında bIsInvincible = True yapın. Anim Notify veya Timer ile belirli süre sonra (0.3s) bIsInvincible = False yapın. TakeDamage fonksiyonunda bIsInvincible kontrolü: True ise hasarı yok sayın. Bu frame süresini dengeli ayarlayın.`],
   ['Cooldown',`Ardarda takla atımını engellemek için: bCanDodge Boolean. Dodge sonrası False yapın. Timer (0.8s) ile True'ya geri döndürün. Stamina maliyeti ekleyebilirsiniz: her dodge 20 stamina harcar. Yetersiz stamina'da dodge yapılamaz.`],
   ['Animasyon Entegrasyonu',`Anim Blueprint\'te: Montage oynatma sırasında hareket kontrolünü kilitleyin. Montage bittiğinde normal state'e dönün. Dodge sırasında Anim Slot kullanarak üst gövde ayrı, alt gövde takla animasyonu oynatılabilir. Afterimage efekti (Ghost Trail) ekleyerek görsel etki artırın.`]],
  [{t:'Dodge Roll',tags:[['fn','PlayMontage'],['fn','LaunchCharacter']],
    d:'Yönlü takla, dokunulmazlık ve cooldown.',
    f:ev('IA_Dodge Started')+`\n  │\n  └──→ ${nd('Branch')} (bCanDodge AND Stamina >= 20)\n        │ True\n        ├──→ DodgeDir = ${fn('Get Last Movement Input')}\n        ├──→ ${nd('Branch')} (DodgeDir = Zero?) → Use Forward\n        ├──→ ${fn('Play Montage')} (DodgeDir → Montage seç)\n        ├──→ bIsInvincible = True\n        ├──→ ${nd('Set Timer')} 0.3s → bIsInvincible = False\n        ├──→ bCanDodge = False\n        ├──→ ${nd('Set Timer')} 0.8s → bCanDodge = True\n        └──→ Stamina -= 20\n\n${ev('TakeDamage Override')}\n  └──→ ${nd('Branch')} (bIsInvincible)\n        │ True → ${cm('Hasarı yok say')}\n        │ False → Normal hasar uygula`,
    v:['bCanDodge: Bool (True)','bIsInvincible: Bool','DodgeForce: 800','DodgeCooldown: 0.8s','DodgeStaminaCost: 20'],
    e:['IA_Dodge Started','TakeDamage']}],
  ['I-frame süresini çok uzun tutmayın, oyun dengesini bozar.','Her yön için ayrı montage kullanmak yerine tek montage + Blend yapabilirsiniz.','Dodge sonrası kısa süre saldırı bonusu vererek agresif oyunu ödüllendirin.'],
  ['Root Motion montage sırasında collision\'ı kapatmayın, duvarın içinden geçebilir.','Multiplayer\'da I-frame\'leri server tarafında doğrulayın.'])},

{cat:'Karakter & Hareket',guide:g('bp-ladder','Merdiven Tırmanma','Başlangıç',
  'Merdivene tutunma ve yukarı/aşağı tırmanma. Trigger volume ile algılama, özel hareket modu ve animasyon.',
  [['Merdiven Actor',`BP_Ladder actor oluşturun. Static Mesh ile merdiven görseli ekleyin. İki Box Collision ekleyin: biri merdivenin tamamını kapsayan Climb Zone, diğeri üst noktada Exit Zone. Arrow Component ile tırmanma yönünü belirtin. Merdiven yüksekliğini (LadderHeight) hesaplayın.`],
   ['Tırmanma Başlatma',`Oyuncu Climb Zone'a girip IA_Interact bastığında: Oyuncunun pozisyonunu merdiven önüne hizalayın (merdivenin X/Y konumu, oyuncunun Z konumu). Rotasyonu merdivene bakacak şekilde ayarlayın. Movement Mode = Flying, Gravity = 0. bIsOnLadder = True.`],
   ['Tırmanma Kontrolü',`bIsOnLadder True iken: W/IA_Move yukarı yönü → yukarı hareket (ClimbSpeed: 200), S → aşağı hareket. Lateral hareketi (sağ/sol) engelleyin. Sürekli Z pozisyonunu Clamp edin: merdiven altı ile üstü arasında. Animasyon: Climb_Up, Climb_Down, Climb_Idle.`],
   ['Çıkış',`Üst çıkış: Exit Zone'a ulaşınca otomatik mantle animasyonu oynatın ve karakteri üst platforma taşıyın. Alt çıkış: Z pozisyonu merdiven altına indiğinde normal yürüme moduna geçin. Manual çıkış: Space veya IA_Interact ile merdivenden atlayarak bırakma.`],
   ['İyileştirmeler',`Tırmanma hızını animasyon ile senkronize edin - Sync Group kullanın. Üst çıkışta kamera yumuşak geçişi için Timeline kullanın. Tırmanma sesleri ekleyin: el ve ayak adımları. Merdiveni dinamik yapabilirsiniz: merdivenin devrilmesi, kırılması gibi mekanikler.`]],
  [{t:'Ladder System',tags:[['fn','SetMovementMode'],['event','OnOverlap']],
    d:'Merdivene tutunma, tırmanma ve çıkış.',
    f:ev('IA_Interact + In Climb Zone')+`\n  │\n  ├──→ ${fn('Set Actor Location')} (Ladder Front)\n  ├──→ ${fn('Set Actor Rotation')} (Face Ladder)\n  ├──→ ${fn('Set Movement Mode')} Flying\n  ├──→ ${fn('Set Gravity')} 0\n  └──→ bIsOnLadder = True\n\n${ev('IA_Move (While On Ladder)')}\n  │\n  ├──→ NewZ = CurrentZ + InputY × ClimbSpeed × DT\n  ├──→ ${nd('Clamp')} (LadderBottom, LadderTop)\n  └──→ ${fn('Set Actor Location')} (LadderX, LadderY, NewZ)\n\n${ev('Reached Top (Exit Zone Overlap)')}\n  ├──→ ${fn('Play Montage')} ClimbOver\n  └──→ ${fn('Set Actor Location')} TopPlatform\n\n${ev('IA_Interact (While On Ladder)')}\n  ├──→ bIsOnLadder = False\n  ├──→ ${fn('Set Movement Mode')} Falling\n  └──→ ${fn('Set Gravity')} 1.0`,
    v:['bIsOnLadder: Bool','ClimbSpeed: 200','LadderHeight: Float'],
    e:['IA_Interact','IA_Move','On Overlap Exit Zone']}],
  ['Merdiven üstüne çıkış montage\'ını Root Motion ile yapın, pozisyon hatası olmaz.','Birden fazla merdiven için aynı BP\'yi kullanın, boyutu instance editable yapın.'],
  ['Flying mode\'da karakter havada kayabilir, lateral hareketi mutlaka sınırlayın.'])},

{cat:'Karakter & Hareket',guide:g('bp-prone','Yatma (Prone) Sistemi','Orta',
  'Karakterin yere yatması. Capsule boyutu en aza iner, hareket çok yavaşlar, kamera yere yaklaşır. Sniper oyunları için ideal.',
  [['Capsule Ayarı',`Prone durumunda Capsule Half Height\'ı 30\'a düşürün (normal: 88, eğilme: 44). Capsule Radius\'ı da küçültebilirsiniz. Set Capsule Size node ile runtime\'da değiştirin. Değişim sırasında zemine Sweep yaparak sıkışmayı önleyin.`],
   ['Geçiş Mantığı',`Ayakta → Eğilme → Yatma şeklinde kademeli geçiş. IA_Prone (Z tuşu) ile: Ayaktayken → doğrudan yatma veya eğilme üzerinden. Yatarken tekrar basınca → eğilmeye geç → tekrar basınca ayağa kalk. Her geçişte Sphere Trace ile üstte engel kontrolü.`],
   ['Hareket ve Hız',`Prone durumunda Max Walk Speed = 100 (çok yavaş sürünme). Crawl animasyonu oynatın. Sadece ileri/geri hareket mümkün, yan hareket çok sınırlı. Tick\'te karakter rotasyonunu yere paralel hale getirin (Pitch ayarı).`],
   ['Kamera Pozisyonu',`Spring Arm Socket Offset Z değerini Timeline ile değiştirin: Ayakta: 70, Eğilme: 40, Yatma: 15. Geçiş süresi 0.4s. Kamera yere yakın olduğu için Post Process ile DoF (Depth of Field) efekti ekleyebilirsiniz.`],
   ['Savaş Entegrasyonu',`Prone durumunda: ateş etme imkanı (prone ateş animasyonu), düşük profil - düşman\'ın görmesi zorlaşır (AI Perception ile). ADS (Aim Down Sight) sırasında sway azalır (sniper avantajı). Prone\'dan hızlı kalkma acil durumlar için gereklidir.`]],
  null,
  ['Prone ve Crouch\'u aynı input sisteminde kademeli yaparsanız daha doğal hisseder.','AI Perception\'da prone karakterin visibility radius\'unu küçültün.'],
  ['Capsule boyutunu çok hızlı değiştirmek sıkışma sorunlarına yol açar, Sweep kullanın.','Prone animasyonu yoksa karakter havada asılı kalır gibi görünür.'])},

// ====== SİLAH & SAVAŞ ======
{cat:'Silah & Savaş Sistemi',guide:g('bp-melee-combo','Yakın Dövüş Kombo Sistemi','Orta',
  'Ardışık tıklamalarla farklı saldırı animasyonları zincirleme. Kombo penceresi, hasar artışı ve son vuruş.',
  [['Kombo Yapısı',`ComboIndex (Integer, 0) değişkeni tanımlayın. Her saldırı tuşu basımında ComboIndex\'e göre farklı montage oynatın: 0→Attack1, 1→Attack2, 2→Attack3 (son vuruş). Montage array\'i kullanın: AttackMontages[ComboIndex]. ComboIndex her saldırıda +1 artar, son adımda 0\'a döner.`],
   ['Kombo Penceresi',`Her saldırı animasyonu içinde bir "Kombo Penceresi" tanımlayın. Bu pencere Anim Notify ile açılır ve kapanır. AN_ComboWindowOpen ve AN_ComboWindowClose notify\'leri oluşturun. Pencere açıkken oyuncu tekrar saldırı tuşuna basarsa kombo devam eder, basamazsa kombo sıfırlanır.`],
   ['Hasar Sistemi',`Her kombo adımında hasar artar: Attack1 = 20, Attack2 = 30, Attack3 = 50 (finisher). Hasar değerlerini array\'de saklayın. Son vuruşta (ComboIndex=2) ekstra efektler: daha büyük hitbox, Camera Shake, Slow Motion (0.3s). Apply Damage node ile hasar uygulayın.`],
   ['Hasar Penceresi',`Anim Notify ile hasar verme zamanlamasını kontrol edin: AN_EnableDamage ve AN_DisableDamage. Silah mesh\'inin collision\'ını bu pencerede aktif edin. Pencere dışında collision kapalıdır - bu sayede swing başında ve sonunda hasar vermez, sadece vuruş anında.`],
   ['Reset ve Cooldown',`Kombo penceresi kapandıktan sonra 0.5s içinde yeni input gelmezse ComboIndex = 0\'a sıfırlayın. Son vuruş (Attack3) sonrası zorunlu recovery süresi (1s) koyun - bu sürede saldırılamaz. Recovery sırasında dodge yapılabilir (cancel mekanizması).`]],
  [{t:'Combo System',tags:[['fn','PlayMontage'],['fn','ApplyDamage'],['class','AnimNotify']],
    d:'Kombo zinciri, hasar penceresi ve sıfırlama.',
    f:ev('IA_Attack Started')+`\n  │\n  └──→ ${nd('Branch')} (bCanAttack AND bComboWindowOpen)\n        │ True\n        ├──→ Montage = AttackMontages[ComboIndex]\n        ├──→ ${fn('Play Montage')} (Montage)\n        ├──→ ComboIndex = (ComboIndex + 1) % 3\n        ├──→ bCanAttack = False\n        └──→ bComboWindowOpen = False\n\n${ev('AN_ComboWindowOpen (Notify)')}\n  └──→ bComboWindowOpen = True\n       ${nd('Set Timer')} 0.5s → Reset Combo\n\n${ev('AN_EnableDamage (Notify)')}\n  └──→ WeaponCollision → Enabled\n\n${ev('AN_DisableDamage (Notify)')}\n  └──→ WeaponCollision → Disabled\n\n${ev('On Weapon Overlap (Enemy)')}\n  ├──→ ${fn('Apply Damage')} DamageValues[ComboIndex]\n  ├──→ ${fn('Spawn Emitter')} HitVFX\n  ├──→ ${fn('Play Sound')} HitSFX\n  └──→ ${nd('Branch')} (ComboIndex = 2)\n        └──→ ${fn('Set Global Time Dilation')} 0.3 (0.1s)`,
    v:['ComboIndex: Int (0)','bComboWindowOpen: Bool','AttackMontages: Array','DamageValues: [20,30,50]','bCanAttack: Bool'],
    e:['IA_Attack Started','AN_ComboWindowOpen','AN_EnableDamage','AN_DisableDamage','On Weapon Overlap']}],
  ['Son vuruşa Screen Shake ve Slow Motion ekleyerek doyurucu his verin.','Kombo penceresi süresini animasyon hızına göre ayarlayın, çok kısa olursa oyuncu yetişemez.','Input Buffer sistemi ekleyerek pencere açılmadan basılan tuşları da kabul edin.'],
  ['Silah collision\'ını sürekli açık bırakmayın, yürürken bile hasar verir.','Montage\'lar arası geçişte Blend Time\'ı 0.1s yapın, çok yüksek olursa yavaş hisseder.'])},

{cat:'Silah & Savaş Sistemi',guide:g('bp-parry','Savuşturma (Parry) Sistemi','İleri',
  'Düşman saldırısını doğru zamanlama ile savuşturma. Başarılı parry düşmanı dengesiz bırakır ve karşı saldırı fırsatı verir.',
  [['Parry Penceresi',`IA_Parry (sağ tık veya Q) ile parry animasyonunu başlatın. Parry montage\'ı oynatın. Montage başlangıcından itibaren 0.3s\'lik "Parry Window" açın (bParryWindowActive = True). 0.3s sonra pencere kapanır. Bu süreyi Anim Notify ile kontrol edin.`],
   ['Hasar Algılama',`TakeDamage event\'ini override edin. bParryWindowActive True ise: hasarı yok sayın, bunun yerine OnParrySuccess event\'ini tetikleyin. Parry\'nin başarısız olması: pencere kapandıktan sonra gelen hasar normal uygulanır. Parry sırasında Block animasyonu da oynatılabilir (parry başarısız olursa block\'a düşer).`],
   ['Düşman Stagger',`Başarılı parry\'de saldıran düşmana sinyal gönderin: Interface fonksiyonu ile OnStaggered çağırın. Düşman: saldırı montage\'ını iptal eder, Stagger montage oynatır, 1.5s boyunca saldıramaz ve savunmasızdır (hasarı %50 artırılmış alır).`],
   ['Karşı Saldırı (Riposte)',`Stagger sırasında oyuncu IA_Attack basarsa özel Riposte montage oynatılır: yüksek hasarlı, sinematik bir karşı saldırı. Riposte hasarı normal saldırının 3 katı. Kamera yakınlaştırma ve Slow Motion efekti ile vurgulayın. Bu saldırı kaçınılamaz (unblockable).`],
   ['Görsel Geri Bildirim',`Parry penceresi açıkken: silah etrafında kısa bir glow efekti. Başarılı parry anında: parlak flash efekti, metalik çarpma sesi, kısa Camera Shake, zaman yavaşlaması (0.05s). Başarısız parry: normal blok sesi ve hafif geri itme. Bu geri bildirimler oyuncunun zamanlamayı öğrenmesini sağlar.`]],
  [{t:'Parry & Riposte',tags:[['fn','PlayMontage'],['class','AnimNotify'],['fn','ApplyDamage']],
    d:'Parry penceresi, stagger ve karşı saldırı.',
    f:ev('IA_Parry Started')+`\n  │\n  ├──→ ${fn('Play Montage')} ParryMontage\n  ├──→ bParryWindowActive = True\n  └──→ ${nd('Set Timer')} 0.3s → bParryWindowActive = False\n\n${ev('TakeDamage (Override)')}\n  │\n  └──→ ${nd('Branch')} (bParryWindowActive)\n        │ True ${cm('PARRY BAŞARILI')}\n        ├──→ ${fn('Play Sound')} ParryClang\n        ├──→ ${fn('Camera Shake')} ParryShake\n        ├──→ ${fn('Set Time Dilation')} 0.1 (0.05s)\n        ├──→ ${fn('Spawn Emitter')} ParryFlash\n        └──→ Attacker → ${fn('OnStaggered')}\n              ├──→ ${fn('Stop Montage')}\n              ├──→ ${fn('Play Montage')} StaggerAnim\n              ├──→ bIsStaggered = True\n              └──→ ${nd('Timer')} 1.5s → bIsStaggered = False\n        │ False\n        └──→ Normal TakeDamage\n\n${ev('IA_Attack + Enemy Staggered')}\n  ├──→ ${fn('Play Montage')} RiposteMontage\n  └──→ ${fn('Apply Damage')} (BaseDamage × 3)`,
    v:['bParryWindowActive: Bool','ParryWindowDuration: 0.3s','RiposteDamageMultiplier: 3.0','bIsStaggered: Bool'],
    e:['IA_Parry Started','TakeDamage Override','IA_Attack (Riposte)']}],
  ['Parry penceresini küçük tutun (0.2-0.3s) - kolay parry oyunu sıkıcılaştırır.','Farklı düşman saldırılarına farklı parry efektleri verin.','Perfect Parry (ilk 0.1s) ve Normal Parry (0.1-0.3s) ayrımı yapabilirsiniz.'],
  ['Parry\'yi çok güçlü yaparsanız oyuncu sadece parry kullanır, dengeyi koruyun.','Multiplayer\'da parry timing\'ini lag\'a göre ayarlayın.'])},

{cat:'Silah & Savaş Sistemi',guide:g('bp-magic-system','Büyü Fırlatma Sistemi','Orta',
  'Mana bazlı büyü sistemi. Farklı büyü tipleri, cast süresi, mana tüketimi ve elementel efektler.',
  [['Büyü Veri Yapısı',`F_SpellData struct oluşturun: SpellName (String), ManaCost (Float), CastTime (Float), Damage (Float), Element (Enum: Fire/Ice/Lightning/Earth), Range (Float), CooldownTime (Float), SpellIcon (Texture2D), ProjectileClass (Actor class ref). Data Table ile büyüleri tanımlayın.`],
   ['Mana Sistemi',`MaxMana (200), CurrentMana değişkenleri. Büyü kullanınca ManaCost kadar azalır. Mana Regen: saniyede ManaRegenRate (5) kadar otomatik yenilenir. Mana potion\'ları ile anında doldurma. HUD\'da mana barı: mavi renk, kullanımda kısa flash efekti.`],
   ['Cast (Büyü Yapma) Süreci',`IA_CastSpell input\'unda: 1) Mana yeterli mi kontrol et. 2) Cooldown\'da mı kontrol et. 3) CastTime > 0 ise: Cast animasyonu başlat, Progress bar göster, CastTime süresi boyunca bekle. Hareket ederse veya hasar alırsa cast kesilir (Interrupt). 4) CastTime tamamlanınca büyüyü serbest bırak.`],
   ['Büyü Tipleri',`Projectile büyüler: Fireball, Ice Spike - SpawnActor ile mermi fırlat. AoE büyüler: Meteor, Lightning Strike - hedef noktada alan hasarı. Self büyüler: Shield, Heal - kendine uygula. Beam büyüler: Lightning Beam - sürekli trace ile hasar. Her tip için farklı spawn ve hasar mantığı.`],
   ['Elementel Etkiler',`Fire: DoT (yanma hasarı 5s), Ice: Slow (%50 yavaşlatma 3s), Lightning: Chain (yakındaki 2 düşmana zıplama), Earth: Stun (1s sersemletme). Element zayıflıkları: Fire > Ice, Ice > Lightning, Lightning > Earth, Earth > Fire. Zayıf elemente karşı %50 ekstra hasar.`]],
  [{t:'Magic System',tags:[['class','DataTable'],['fn','SpawnActor'],['fn','ApplyDamage']],
    d:'Mana, cast süreci, büyü tipleri ve elementel etkiler.',
    f:ev('IA_CastSpell Started')+`\n  │\n  ├──→ SpellData = ${fn('Get Data Table Row')} ActiveSpell\n  ├──→ ${nd('Branch')} (Mana >= ManaCost AND !OnCooldown)\n  │     │ True\n  │     ├──→ Mana -= ManaCost\n  │     ├──→ ${fn('Play Montage')} CastAnim\n  │     ├──→ ${nd('Branch')} (CastTime > 0)\n  │     │     │ True ${cm('Channeled')}\n  │     │     ├──→ Show Cast Bar\n  │     │     └──→ ${nd('Delay')} CastTime\n  │     │           └──→ ${fn('ReleaseSpell')}\n  │     │     │ False ${cm('Instant')}\n  │     │     └──→ ${fn('ReleaseSpell')}\n  │     └──→ ${nd('Set Timer')} CooldownTime\n  │\n  └──→ ${cm('Yetersiz mana veya cooldown')}\n\n${fn('ReleaseSpell')} (SpellData)\n  ├──→ ${nd('Switch on SpellType')}\n  │     ├──→ Projectile: ${fn('Spawn Actor')} SpellData.ProjectileClass\n  │     ├──→ AoE: ${fn('Apply Radial Damage')} at Target\n  │     ├──→ Self: ${fn('Apply Buff')} to Caster\n  │     └──→ Beam: Start Beam Trace\n  └──→ Apply Element Effect on Hit`,
    v:['MaxMana: 200','CurrentMana: Float','ManaRegenRate: 5/s','ActiveSpellSlot: Int','SpellCooldowns: Map'],
    e:['IA_CastSpell Started','ReleaseSpell','On Spell Hit']}],
  ['Büyü seçimini sayı tuşları (1-4) veya radyal menü ile yapın.','Cast sırasında hareket edemeyen büyüler daha güçlü olmalı - risk/ödül dengesi.','Elementel kombinasyonlar ekleyin: Fire + Ice = Steam (görüş engeli).'],
  ['Mana regenini çok hızlı yaparsanız mana sistemi anlamsızlaşır.','Cast interrupt mekanizmasını unutmayın, yoksa oyuncu hiç kesilmeden büyü yapar.'])},

// ====== YAPAY ZEKA (AI) ======
{cat:'Yapay Zeka (AI)',guide:g('bp-ai-boss-phases','Boss Faz Sistemi','İleri',
  'Boss düşmanın can eşiklerine göre farklı saldırı kalıplarına geçmesi. Her fazda yeni saldırılar, hız artışı ve mekanikler.',
  [['Faz Yapısı',`F_BossPhase struct: PhaseIndex (Int), HealthThreshold (Float: 1.0, 0.6, 0.3), AttackPatterns (Array), MoveSpeed (Float), DamageMultiplier (Float), SpecialAbilities (Array). Boss\'un canı eşiğin altına düşünce bir sonraki faza geçiş. Toplam 3 faz ideal: Faz 1 (100-60%), Faz 2 (60-30%), Faz 3 (30-0%).`],
   ['Faz Geçişi',`TakeDamage sonrası Health / MaxHealth oranını kontrol edin. Oran yeni fazın eşiğinin altına düşerse: OnPhaseTransition event tetikleyin. Bu event sırasında: Boss kısa süre (2s) dayanıksız olur, özel geçiş animasyonu oynatılır (kükreme, güç toplama), yeni saldırı kalıpları aktif olur, müzik değişir.`],
   ['Saldırı Kalıpları',`Her fazın kendine özgü saldırı array\'i vardır. Behavior Tree\'de faz kontrolü: Blackboard\'da CurrentPhase Integer. Decorator ile faz bazlı dallanma. Faz 1: Basit melee saldırılar, ara sıra range. Faz 2: Hızlı kombo, AoE saldırı eklenir. Faz 3: Tüm saldırılar güçlenir, yeni ultimate saldırı açılır.`],
   ['Enrage Mekaniği',`Faz 3\'te Boss "enrage" moduna girer: saldırı hızı %50 artar, hasar %30 artar, yeni patternlar açılır. Görsel: kırmızı aura, gözler parlar, ortam rengi değişir. Bu faz oyuncuyu baskı altına alarak final hissini verir.`],
   ['Boss UI',`Ekranın üstünde büyük Health Bar. Her faz için farklı renk: Faz 1 yeşil, Faz 2 sarı, Faz 3 kırmızı. Faz geçişinde bar\'da görsel efekt. Boss adı ve başlığı gösterin. Opsiyonel: saldırı pattern\'ını gösteren küçük ikonlar (telegraph).`]],
  [{t:'Boss Phases',tags:[['class','BehaviorTree'],['fn','ApplyDamage']],
    d:'Can eşikli faz geçişi, saldırı kalıpları.',
    f:ev('TakeDamage')+`\n  │\n  ├──→ Health -= Damage\n  ├──→ HealthPercent = Health / MaxHealth\n  └──→ ${nd('Branch')} (HealthPercent < NextPhaseThreshold)\n        │ True\n        ├──→ CurrentPhase += 1\n        ├──→ ${fn('Play Montage')} PhaseTransition\n        ├──→ bIsInvulnerable = True (2s)\n        ├──→ ${fn('Update Attack Patterns')}\n        │     ├──→ MoveSpeed × 1.3\n        │     ├──→ DamageMultiplier × 1.2\n        │     └──→ Unlock New Attacks\n        ├──→ ${fn('Change Music')} Phase${nd('CurrentPhase')}Music\n        ├──→ ${fn('Camera Shake')} BossTransition\n        └──→ ${fn('Update Boss UI')}\n\n${cm('Behavior Tree Decorator:')}\n  ${nd('Branch')} CurrentPhase = ?\n  ├──→ Phase 1: BasicMelee → RangedAttack\n  ├──→ Phase 2: FastCombo → AoE → RangedAttack\n  └──→ Phase 3: AllAttacks → Ultimate → Enrage`,
    v:['CurrentPhase: Int','PhaseThresholds: [1.0, 0.6, 0.3]','bIsEnraged: Bool','DamageMultiplier: Float'],
    e:['TakeDamage','OnPhaseTransition']}],
  ['Faz geçişinde kısa invincibility vererek oyuncunun hazırlanmasını sağlayın.','Her faz için farklı müzik kullanarak gerilim artırın.','Faz 3\'te boss\'un yeni görsel efektler kazanması (aura, renk değişimi) farkı belirginleştirir.'],
  ['Faz geçişi sırasında hasar almayı engelleyin, aksi halde faz atlanabilir.','Boss saldırı kalıplarını çok karmaşık yapmayın, oyuncu öğrenebilmeli.'])},

{cat:'Yapay Zeka (AI)',guide:g('bp-ai-companion','Yardımcı AI (Companion)','İleri',
  'Oyuncuyu takip eden, savaşta yardım eden ve komutlara uyan AI yardımcı. Follow, Attack, Stay komutları.',
  [['Temel Takip',`Companion AI\'ın Behavior Tree\'sinde varsayılan davranış: Oyuncuyu takip et. AI Move To ile oyuncunun yakınında kal (FollowDistance: 200). Oyuncu durduğunda companion da dursun. Acceptance Radius ile tam üzerine gelmesin. Oyuncu çok hızlı uzaklaşırsa (mesafe > 1000) teleport edin.`],
   ['Komut Sistemi',`Oyuncudan companion\'a komutlar: Follow (takip et), Attack (saldır), Stay (bekle), Come (gel). Radyal menü veya kısayol tuşları ile komut verin. Blackboard\'da CurrentCommand enum değişkeni. Her komut farklı BT dalını aktif eder. UI\'da mevcut komutu gösteren ikon.`],
   ['Savaş Davranışı',`Attack komutunda: Oyuncunun hedeflediği düşmana saldır. Hedef yoksa en yakın düşmanı seç. Companion melee veya ranged olabilir. Savaş sırasında: dodge yapabilir (rastgele), can düşükken geri çekilir, düşman ölünce yeni hedef arar veya oyuncuya döner.`],
   ['Can ve Revive',`Companion\'ın kendi Health sistemi. Can sıfırlanınca "downed" state: yere düşer, yavaşça can kaybeder. Oyuncu yaklaşıp IA_Interact ile canlandırabilir (3s hold). Canlanma sonrası %50 can ile geri döner. Companion tamamen ölürse belirli süre sonra respawn.`],
   ['İletişim',`Companion durumu hakkında sesli/yazılı geri bildirim: "Düşman görüyorum!", "Takip ediyorum", "Yardıma ihtiyacım var!". Bark sistemi ile rastgele diyaloglar. Oyuncunun yanında idle iken ortam hakkında yorum yapma. Bu diyaloglar Data Table\'dan çekilir.`]],
  [{t:'Companion AI',tags:[['class','BehaviorTree'],['fn','AIMoveTO'],['fn','ApplyDamage']],
    d:'Takip, komut sistemi, savaş ve canlanma.',
    f:cm('Behavior Tree Root')+`\n  │\n  ├──→ ${nd('Selector')} (CurrentCommand)\n  │     │\n  │     ├──→ ${cm('Follow Mode')}\n  │     │     ├──→ ${fn('AI Move To')} (Player, Radius: 200)\n  │     │     └──→ ${nd('Branch')} Distance > 1000\n  │     │           └──→ ${fn('Teleport')} Near Player\n  │     │\n  │     ├──→ ${cm('Attack Mode')}\n  │     │     ├──→ ${fn('Find Target')} (Player\'s target or nearest)\n  │     │     ├──→ ${fn('AI Move To')} (Target, Attack Range)\n  │     │     ├──→ ${fn('Play Montage')} AttackAnim\n  │     │     └──→ ${fn('Apply Damage')} (Target)\n  │     │\n  │     ├──→ ${cm('Stay Mode')}\n  │     │     └──→ Idle at current position\n  │     │\n  │     └──→ ${cm('Come Mode')}\n  │           └──→ ${fn('AI Move To')} (Player, Radius: 100)\n  │\n  └──→ ${cm('Health Check')}\n        └──→ ${nd('Branch')} (Health <= 0)\n              └──→ Enter Downed State`,
    v:['CurrentCommand: Enum','FollowDistance: 200','CompanionHealth: Float','bIsDowned: Bool'],
    e:['OnCommandReceived','OnTargetFound','OnDowned','OnRevived']}],
  ['Companion\'ın pathfinding kalitesini test edin, dar alanlarda sıkışmamalı.','Companion\'a basit duygusal tepkiler verin (sevinç, korku) - oyuncu bağ kurar.','Savaşta companion\'ın çok güçlü olmaması önemli, oyuncu hâlâ ana savaşçı olmalı.'],
  ['NavMesh\'in companion\'ın boyutuna uygun olduğundan emin olun.','Teleport\'u görünür yapın (partikül efekti), aniden belirme tuhaf durur.'])},

{cat:'Yapay Zeka (AI)',guide:g('bp-ai-stealth-detection','Stealth Algılama Sistemi','Orta',
  'Düşmanın oyuncuyu aşamalı olarak fark etmesi. Şüphe barı, görüş açısı, mesafe ve çevresel faktörler.',
  [['Algılama Barı',`Her düşmanın DetectionMeter (Float, 0-100) değişkeni. 0 = farkında değil, 50 = şüpheli, 100 = tamamen farkında (alarm). Oyuncu görüş alanındayken meter dolarak artar. Oyuncu saklandığında meter azalır. Meter hızı mesafeye, aydınlatmaya ve hareket hızına bağlıdır.`],
   ['Görüş Alanı (FOV)',`AI Perception Component kullanın: Sight sense ekleyin. Sight Radius: 2000, Lose Sight Radius: 2500, Peripheral Vision Angle: 60 derece. Oyuncu bu koni içindeyse ve Line Trace ile arada engel yoksa "görülebilir" durumdadır. Peripheral\'de (kenar görüş) algılama daha yavaş olsun.`],
   ['Çevresel Faktörler',`Aydınlatma: Oyuncunun bulunduğu noktadaki ışık seviyesini kontrol edin. Karanlıkta algılama çok yavaş veya imkansız. Gürültü: Oyuncu koşarsa, ateş ederse, cam kırarsa ses çıkarır - AI Hearing ile algılanır. Hareket hızı: Eğilme + yavaş hareket = düşük algılama, sprint = yüksek algılama.`],
   ['Durum Geçişleri',`0-30: Normal devriye. 30-70: Şüpheli - "Hm?" animasyonu, son görülen konuma doğru yürü, etrafı araştır. 70-100: Savaş hazırlığı - silahını çıkar, takım arkadaşlarını uyar. 100: Tam alarm - saldır, takviye çağır. Her seviyede farklı UI göstergesi (sarı→turuncu→kırmızı ikon).`],
   ['Gizlenme',`Oyuncu saklanma noktalarında (çalı, kutu arkası, karanlık köşe) DetectionMeter\'ı hızla düşer. "Hidden" state\'te AI oyuncuyu göremez ama son bilinen konuma gider. Araştırma süresi sonrası (15s) normal devriyeye döner. Gizlenme yerlerini Tag veya Actor ile işaretleyin.`]],
  [{t:'Stealth Detection',tags:[['class','AIPerception'],['class','BehaviorTree']],
    d:'Aşamalı algılama, şüphe barı ve gizlenme.',
    f:ev('On Perception Updated')+`\n  │\n  ├──→ ${nd('Branch')} (Sensed Actor = Player)\n  │     │ True\n  │     ├──→ Distance = Player - Self\n  │     ├──→ LightLevel = ${fn('Get Light at Location')} (Player)\n  │     ├──→ MovementSpeed = Player.Speed\n  │     ├──→ DetectionRate = BaseRate\n  │     │     × DistanceMod (yakin=hızlı)\n  │     │     × LightMod (aydınlık=hızlı)\n  │     │     × MoveMod (hızlı=hızlı)\n  │     ├──→ DetectionMeter += DetectionRate × DT\n  │     └──→ ${nd('Branch')} DetectionMeter Value\n  │           ├──→ 0-30: ${cm('Normal Patrol')}\n  │           ├──→ 30-70: ${cm('Suspicious')}\n  │           │     └──→ ${fn('Investigate')} LastKnownLoc\n  │           ├──→ 70-99: ${cm('Alert')}\n  │           │     └──→ ${fn('Call Reinforcements')}\n  │           └──→ 100: ${cm('Full Combat')}\n  │                 └──→ ${fn('Engage Player')}\n  │\n  └──→ ${cm('Player not visible')}\n        └──→ DetectionMeter -= DecayRate × DT`,
    v:['DetectionMeter: Float (0-100)','BaseDetectionRate: 15/s','DecayRate: 20/s','AlertThreshold: 100'],
    e:['On Perception Updated','OnSuspicious','OnAlert','OnCombat']}],
  ['Düşmanın başı üzerinde şüphe göstergesi (ikon veya bar) oyuncuya geri bildirim verir.','Işık seviyesi kontrolü için Line Trace ile gölge tespiti yapabilirsiniz.','Ses algılamasını ayrı bir kanal olarak ayarlayın, görüş ile karıştırmayın.'],
  ['Algılama oranını çok hızlı yaparsanız stealth imkansız olur, dengeleyin.','AI araştırma süresini kısa tutmayın, oyuncu stratejik gizlenme yapabilmeli.'])},

// ====== UI / HUD ======
{cat:'UI / HUD Sistemi',guide:g('bp-ui-healthbar-anim','Animasyonlu Sağlık Barı','Başlangıç',
  'Hasar alındığında anlık düşen kırmızı bar ve yavaşça takip eden sarı bar efekti. Profesyonel oyunlardaki gibi çift katmanlı health bar.',
  [['Widget Yapısı',`WBP_HealthBar widget oluşturun. İki adet Progress Bar üst üste koyun: 1) BackgroundBar (sarı) - altta, 2) ForegroundBar (yeşil/kırmızı) - üstte. Aynı boyut ve pozisyonda olmalılar. ForegroundBar hasar alınca hemen düşer, BackgroundBar gecikmeli olarak takip eder.`],
   ['Anlık Güncelleme',`UpdateHealth fonksiyonu oluşturun. Parametre: NewHealthPercent (0-1 arası). ForegroundBar\'ın Percent değerini hemen NewHealthPercent\'e ayarlayın. Renk: %60 üzeri yeşil, %30-60 sarı, %30 altı kırmızı. Renk geçişi Linear Color Lerp ile.`],
   ['Gecikmeli Takip (Drain Effect)',`BackgroundBar\'ı hemen güncellemek yerine 0.5s bekletin. Sonra Timeline veya Tick ile BackgroundBar.Percent\'i ForegroundBar.Percent\'e doğru yavaşça azaltın (FInterp, hız: 2.0). Bu "drain" efekti kaybedilen canı sarı olarak gösterir.`],
   ['Hasar Flash',`Hasar alınca Health Bar\'da kısa bir beyaz flash efekti: Color and Opacity animasyonu Widget Animation ile yapın. 0.1s beyaz, sonra normal renge dön. Ayrıca bar\'ın kenarında kırmızı pulse efekti ekleyebilirsiniz.`],
   ['Entegrasyon',`Character BP\'de TakeDamage event\'inde: HealthPercent hesaplayın (CurrentHealth/MaxHealth). WBP_HealthBar\'ın UpdateHealth fonksiyonunu çağırın. İyileşme (Heal) durumunda da aynı fonksiyon çalışır ama ters yönde: yeşil bar yukarı çıkar, sarı bar zaten eşittir.`]],
  [{t:'Animated Health Bar',tags:[['class','UserWidget'],['fn','PlayAnimation'],['class','ProgressBar']],
    d:'Çift katmanlı hasar gösterimi.',
    f:fn('UpdateHealth')+` (NewPercent)\n  │\n  ├──→ ForegroundBar.Percent = NewPercent\n  ├──→ ${fn('Play Widget Animation')} DamageFlash\n  │\n  ├──→ ${cm('Renk hesaplama:')}\n  │     ├──→ > 0.6: Yeşil\n  │     ├──→ 0.3-0.6: Sarı\n  │     └──→ < 0.3: Kırmızı\n  │\n  ├──→ ${nd('Delay')} 0.5s\n  └──→ Start Drain:\n        └──→ ${ev('Event Tick')}\n              └──→ BackgroundBar.Percent = ${fn('FInterpTo')}\n                    (Current, ForegroundBar.Percent, DT, 2.0)\n\n${cm('Character BP\'den çağırma:')}\n  ${ev('Event Any Damage')}\n  ├──→ Health -= Damage\n  ├──→ Percent = Health / MaxHealth\n  └──→ HealthBarWidget → ${fn('UpdateHealth')} (Percent)`,
    v:['ForegroundPercent: Float','BackgroundPercent: Float','DrainSpeed: 2.0','DrainDelay: 0.5s'],
    e:['UpdateHealth','Event Tick (Drain)']}],
  ['%20 altında bar\'ı titreterek aciliyet hissi verin.','İyileşme durumunda yeşil parıltı efekti ekleyin.','Boss health bar\'ında da aynı sistemi kullanın ama daha büyük boyutta.'],
  ['Her frame FInterp çalıştırmak yerine, drain aktif olduğunda bir flag ile kontrol edin.'])},

{cat:'UI / HUD Sistemi',guide:g('bp-ui-inventory-grid','Envanter Grid Sistemi','Orta',
  'Diablo/Resident Evil tarzı grid tabanlı envanter. Eşyalar farklı boyutlarda (1x1, 2x1, 2x3) ve sürükle-bırak ile yerleştirme.',
  [['Grid Veri Yapısı',`2D Boolean array ile grid\'i temsil edin: GridWidth (10), GridHeight (6). Her hücre dolu (True) veya boş (False). F_InventoryItem struct: ItemID, ItemName, GridPosition (IntPoint), ItemSize (IntPoint: 1x1, 2x1 vb), Icon (Texture2D), ItemData (class ref).`],
   ['Slot Widget',`WBP_GridSlot widget: belirli boyutta Button veya Image. Dolu ise eşya ikonu gösterir, boş ise grid arka planı. Grid\'i oluşturmak için: Uniform Grid Panel içinde dinamik olarak GridWidth × GridHeight adet slot oluşturun. Her slot\'a grid koordinatı atayın.`],
   ['Eşya Yerleştirme',`AddItem fonksiyonu: Eşyanın boyutuna (örn: 2x3) uygun boş alan bul. Sol üstten sağa, yukarıdan aşağı tara. Her pozisyonda eşya sığıyor mu kontrol et (tüm hücreler boş mu). Uygun yer bulunca grid hücrelerini dolu olarak işaretle, eşya ikonunu göster.`],
   ['Sürükle Bırak',`Eşya üzerine Mouse Down: Drag Drop Operation oluştur. Eşyayı grid\'den kaldır (hücreleri boşalt). Mouse ile sürüklerken eşya ikonu mouse\'u takip eder. Hedef pozisyona bırakınca: o pozisyonda yeterli boş alan var mı kontrol et. Varsa yerleştir, yoksa eski yerine geri koy.`],
   ['Rotasyon ve Taşma',`Opsiyonel: R tuşu ile eşyayı 90° döndürme (Width↔Height değiştirme). Sürükleme sırasında geçerli pozisyonları yeşil, geçersiz pozisyonları kırmızı ile vurgulayın. Envanter dolu uyarısı. Eşya üzerine hover ile tooltip (isim, açıklama, statlar).`]],
  [{t:'Grid Inventory',tags:[['class','UserWidget'],['class','DragDropOperation']],
    d:'Grid tabanlı envanter, boyutlu eşyalar ve drag-drop.',
    f:fn('AddItem')+` (Item)\n  │\n  ├──→ For Y = 0 to GridHeight - Item.SizeY:\n  │     For X = 0 to GridWidth - Item.SizeX:\n  │           ├──→ ${nd('Branch')} (All cells free?)\n  │           │     │ True\n  │           │     ├──→ Mark cells as Occupied\n  │           │     ├──→ Item.GridPos = (X, Y)\n  │           │     └──→ ${fn('Update Slot Visuals')}\n  │           │           Return True\n  │           └──→ Continue search\n  └──→ Return False ${cm('(Yer yok)')}\n\n${ev('On Mouse Down (Slot)')}\n  ├──→ ${fn('Remove Item From Grid')}\n  └──→ ${fn('Create Drag Drop Op')} (Item Icon)\n\n${ev('On Drop (Target Slot)')}\n  ├──→ TargetPos = Slot.GridPosition\n  ├──→ ${nd('Branch')} (CanPlace at TargetPos?)\n  │     │ True → ${fn('AddItem at Position')}\n  │     │ False → ${fn('Return to Original Pos')}\n  └──→ ${fn('Update Grid Visuals')}`,
    v:['Grid: 2D Bool Array','GridWidth: 10','GridHeight: 6','Items: Array of F_InventoryItem'],
    e:['AddItem','RemoveItem','On Mouse Down','On Drop']}],
  ['Eşya boyutlarını dikkatlice dengeleyin - çok büyük eşyalar envanter yönetimini stresli yapar.','Auto-sort butonu ekleyerek eşyaları otomatik düzenleyin.','Grid arka planına hafif çizgiler ekleyerek hücre sınırlarını belirginleştirin.'],
  ['Drag sırasında orijinal pozisyonu kaydedin, bırakma başarısız olursa geri koyun.','2D array\'de sınır kontrolü yapın, index out of bounds hatası olabilir.'])},

// ====== EFEKTLER ======
{cat:'Efekt & Partikül',guide:g('bp-vfx-hit-impact','Vuruş Darbe Efekti Sistemi','Orta',
  'Farklı yüzeylere vuruşta farklı efektler: metal kıvılcım, ahşap kıymık, beton toz, kan. Physical Material bazlı otomatik seçim.',
  [['Physical Material Sistemi',`Her yüzey tipi için Physical Material oluşturun: PM_Metal, PM_Wood, PM_Concrete, PM_Flesh, PM_Dirt, PM_Water. Static Mesh\'lerin material\'larına bu Physical Material\'ları atayın. Hit sonucunda Physical Material bilgisi Hit Result\'tan alınabilir.`],
   ['Efekt Eşleme',`F_ImpactEffect struct: PhysMaterial (Physical Material ref), ParticleEffect (Niagara System), Sound (Sound Cue), Decal (Material Instance). Data Table ile eşleştirme yapın. Hit olduğunda: Physical Material\'a göre Data Table\'dan doğru efekti çekin.`],
   ['Spawn Mantığı',`SpawnImpactEffect fonksiyonu oluşturun. Parametreler: HitLocation, HitNormal, PhysMaterial. Fonksiyon: 1) Data Table\'dan efekt verisi çek, 2) Niagara particle spawn (HitLocation, Normal yönünde), 3) Sound spawn (HitLocation\'da), 4) Decal spawn (HitNormal rotasyonunda, yüzeye yapışık).`],
   ['Mermi Vuruş Efekti',`Line Trace veya Projectile hit\'te SpawnImpactEffect çağırın. Metal yüzeyde: kıvılcım (Niagara, turuncu parçacıklar), metalik çarpma sesi, hafif çukur decal. Ahşapta: tahta kıymık parçacıkları, tahta kırılma sesi, çatlak decal. Beton: toz bulutu, taş kırılma sesi, kurşun deliği decal.`],
   ['Performans',`Decal havuzu (Pool) kullanın: maksimum 50 aktif decal, yenisi gelince eskisini kaldırın. Particle\'lar auto-destroy olsun. Uzak mesafedeki efektleri küçültün veya atlayın (LOD benzeri). Sound Concurrency ile aynı anda çalan benzer sesleri sınırlayın.`]],
  [{t:'Impact Effects',tags:[['class','PhysicalMaterial'],['class','DataTable'],['fn','SpawnEmitter']],
    d:'Yüzey bazlı vuruş efekti, ses ve decal.',
    f:fn('SpawnImpactEffect')+` (HitResult)\n  │\n  ├──→ PhysMat = HitResult.PhysMaterial\n  ├──→ EffectData = ${fn('Get Data Table Row')} (PhysMat)\n  │\n  ├──→ ${fn('Spawn System at Location')}\n  │     ├──→ System: EffectData.Particle\n  │     ├──→ Location: HitResult.Location\n  │     └──→ Rotation: HitResult.Normal\n  │\n  ├──→ ${fn('Play Sound at Location')}\n  │     ├──→ Sound: EffectData.Sound\n  │     └──→ Location: HitResult.Location\n  │\n  └──→ ${fn('Spawn Decal at Location')}\n        ├──→ Material: EffectData.Decal\n        ├──→ Location: HitResult.Location\n        ├──→ Rotation: HitResult.Normal → Rotator\n        ├──→ Size: (10, 10, 10)\n        └──→ Lifespan: 30s`,
    v:['ImpactDataTable: DataTable','MaxDecals: 50','DecalPool: Array'],
    e:['OnWeaponHit','OnProjectileImpact']}],
  ['Her Physical Material için 2-3 farklı ses varyasyonu kullanarak tekrarlı hissi önleyin.','Decal boyutlarını silah tipine göre değiştirin: tabanca küçük, shotgun büyük.','Kan efekti için ayrı bir sistem kurun, karakter vurulduğunda farklı yöne sıçrasın.'],
  ['Çok fazla decal performansı düşürür, mutlaka pool sistemi kullanın.','Niagara System\'ın Auto Destroy özelliğini aktif edin, yoksa bellekte birikir.'])},

// ====== SES ======
{cat:'Ses & Müzik',guide:g('bp-audio-footstep-advanced','Gelişmiş Ayak Sesi Sistemi','Orta',
  'Zemin tipine göre farklı ayak sesi. Physical Material bazlı ses seçimi, hız bazlı ses frekansı ve yoğunluğu.',
  [['Zemin Algılama',`Her adım anında (Anim Notify: AN_FootStep) ayağın altından kısa bir Line Trace atın. Hit edilen yüzeyin Physical Material\'ını alın. PM_Grass, PM_Stone, PM_Wood, PM_Metal, PM_Water gibi materyaller tanımlayın.`],
   ['Ses Eşleme',`F_FootstepSound struct: PhysMaterial, SoundArray (Sound Cue array - her zemin için 4-5 farklı ses). Map veya Data Table kullanın. Physical Material\'a göre uygun ses array\'ini çekin. Array\'den rastgele bir ses seçin (tekrar önleme ile).`],
   ['Tekrar Önleme',`Aynı sesin ardarda çalmasını engelleyin: LastPlayedIndex kaydedin. Yeni ses seçerken aynı index gelmemesini sağlayın. Random + önceki index kontrolü. Bu küçük detay ses kalitesini büyük ölçüde artırır.`],
   ['Hareket Hızı Etkisi',`Yürüme ve koşma sesleri farklı: Hız < 300 = yürüme sesleri (hafif), Hız > 300 = koşma sesleri (güçlü, daha sık). Sprint sırasında ses frekansını artırın. Eğilme (Crouch) sırasında ses çok hafif ve seyrek olsun.`],
   ['Su ve Özel Zeminler',`Su birikintisi üzerinde splash efekti + su sesi. Kar üzerinde crunch sesi + küçük kar partikülü. Çamur üzerinde yapışkan ses. Metal üzerinde metalik yankı. Her özel zemin için hem ses hem küçük görsel efekt.`]],
  [{t:'Footstep System',tags:[['fn','LineTrace'],['class','PhysicalMaterial'],['fn','PlaySound']],
    d:'Zemin bazlı ayak sesi, hız etkisi.',
    f:ev('AN_FootStep (Anim Notify)')+`\n  │\n  ├──→ ${fn('Line Trace Down')} from Foot Socket (50 units)\n  ├──→ PhysMat = HitResult.PhysMaterial\n  ├──→ Sounds = ${fn('Get Footstep Sounds')} (PhysMat)\n  │\n  ├──→ Speed = Character.Velocity.Length\n  ├──→ ${nd('Branch')} (Speed > 300)\n  │     ├──→ True: SoundSet = Sounds.Running\n  │     └──→ False: SoundSet = Sounds.Walking\n  │\n  ├──→ RandomIndex = ${nd('Random')} (0, SoundSet.Length-1)\n  ├──→ ${nd('Branch')} (RandomIndex = LastIndex)\n  │     └──→ Reshuffle\n  ├──→ LastIndex = RandomIndex\n  │\n  ├──→ Volume = ${fn('Map Range')} (Speed, 100→600, 0.3→1.0)\n  └──→ ${fn('Play Sound at Location')}\n        ├──→ Sound: SoundSet[RandomIndex]\n        ├──→ Volume: Volume\n        └──→ Location: Foot Position`,
    v:['FootstepSounds: Map<PhysMat, SoundArray>','LastPlayedIndex: Int','SpeedThreshold: 300'],
    e:['AN_FootStep (Anim Notify)']}],
  ['Her zemin için en az 4 farklı ses kaydı kullanın, az ses tekrarlı hissettirir.','Eğilme sırasında ses volume\'unu %30\'a düşürün.','AI düşmanları da bu sistemi kullansın, oyuncu düşman ayak sesini duyabilsin.'],
  ['Anim Notify timing\'ini animasyona tam oturtun, gecikmeli ayak sesi yapay hissettirir.','Line Trace\'i her frame değil sadece notify anında atın, performans için.'])},

// ====== KAYDETME ======
{cat:'Kaydetme & Yükleme',guide:g('bp-save-full','Tam Save/Load Sistemi','Orta',
  'Oyuncu ilerlemesi, envanter, quest durumu, dünya state\'i ve ayarları kaydetme/yükleme. Çoklu slot desteği.',
  [['SaveGame Class',`USaveGame\'den türeyen BP_MySaveGame oluşturun. İçine tüm kaydetmek istediğiniz verileri ekleyin: PlayerLocation (Vector), PlayerRotation (Rotator), PlayerHealth (Float), PlayerLevel (Int), InventoryItems (Array of F_SavedItem), CompletedQuests (Array of String), WorldState (Map of String→Bool), PlayTime (Float), SaveDateTime (DateTime).`],
   ['Kaydetme',`SaveGame fonksiyonu: 1) BP_MySaveGame instance oluştur (Create Save Game Object). 2) Tüm verileri oyun state\'inden save objesine kopyala. 3) Save Game to Slot node: SlotName ve UserIndex parametreleri. SlotName = "Slot1", "Slot2", "Slot3" gibi. Does Save Game Exist ile slot dolu mu kontrol edin.`],
   ['Yükleme',`LoadGame fonksiyonu: 1) Does Save Game Exist ile kontrol. 2) Load Game from Slot ile save objesini geri alın. 3) Cast to BP_MySaveGame. 4) Verileri sırayla uygulayın: Set Actor Location, Health set, Envanter rebuild, Quest state restore. Level farklıysa Open Level sonrası yükleyin.`],
   ['Dünya State Kaydetme',`Kapıların açık/kapalı, sandıkların boş/dolu, düşmanların öldürülmüş olması gibi dünya durumlarını kaydedin. Her kaydetme gerektiren actor\'e bir UniqueID verin. Map<String, Bool> ile kaydedin: "Door_Castle_01" → True (açık). Yükleme sırasında her actor kendi ID\'sine bakarak state\'ini set eder.`],
   ['Çoklu Slot ve UI',`3-5 kayıt slotu sunun. Save/Load menüsünde her slot gösterilir: oyuncu seviyesi, oyun süresi, kayıt tarihi, küçük screenshot. Boş slotlara "Boş Slot" yazın. Üzerine kaydetme onay dialogu gösterin. Auto-save özelliği: belirli aralıklarla otomatik kayıt (ayrı slot).`]],
  [{t:'Save Load System',tags:[['class','SaveGame'],['fn','SaveGameToSlot'],['fn','LoadGameFromSlot']],
    d:'Tam save/load, çoklu slot, dünya state.',
    f:fn('SaveGame')+` (SlotName)\n  │\n  ├──→ Save = ${fn('Create Save Game Object')} BP_MySaveGame\n  ├──→ Save.Location = Player.Location\n  ├──→ Save.Rotation = Player.Rotation\n  ├──→ Save.Health = Player.Health\n  ├──→ Save.Level = Player.Level\n  ├──→ Save.Inventory = ${fn('Serialize Inventory')}\n  ├──→ Save.Quests = ${fn('Get Completed Quests')}\n  ├──→ Save.WorldState = ${fn('Collect World State')}\n  ├──→ Save.PlayTime = TotalPlayTime\n  ├──→ Save.DateTime = ${fn('Now')}\n  └──→ ${fn('Save Game to Slot')} (Save, SlotName, 0)\n\n${fn('LoadGame')} (SlotName)\n  │\n  ├──→ ${nd('Branch')} ${fn('Does Save Exist')} (SlotName)\n  │     │ True\n  │     ├──→ Save = ${fn('Load Game from Slot')} (SlotName)\n  │     ├──→ ${fn('Set Actor Location')} Save.Location\n  │     ├──→ ${fn('Set Health')} Save.Health\n  │     ├──→ ${fn('Rebuild Inventory')} Save.Inventory\n  │     ├──→ ${fn('Restore Quests')} Save.Quests\n  │     └──→ ${fn('Apply World State')} Save.WorldState\n  └──→ False: ${cm('Kayıt yok')}`,
    v:['SaveSlots: ["Slot1","Slot2","Slot3"]','AutoSaveInterval: 300s','CurrentSlot: String'],
    e:['SaveGame','LoadGame','AutoSave Timer']}],
  ['Auto-save\'i ayrı bir slotta yapın, oyuncunun manuel save\'inin üzerine yazmayın.','Save işlemi sırasında kısa bir "Kaydediliyor..." ikonu gösterin.','Yükleme başarısız olursa varsayılan değerlerle başlayın, crash olmayın.'],
  ['Save\'e çok fazla veri koymak dosya boyutunu şişirir, sadece gerekli verileri kaydedin.','Save sırasında oyun donabilir, Async Save kullanmayı düşünün.'])},

// ====== OPTİMİZASYON ======
{cat:'Optimizasyon',guide:g('bp-opt-tick-management','Tick Yönetimi ve Performans','Orta',
  'Event Tick kullanımını minimize ederek performansı artırma. Timer, event-driven yaklaşım ve tick grupları.',
  [['Tick Sorunu',`Her actor\'ün Event Tick\'i her frame çalışır (60fps\'te saniyede 60 kez). 100 actor × 60fps = 6000 tick çağrısı/saniye. Bu büyük performans maliyetidir. Çoğu actor\'ün sürekli tick\'e ihtiyacı yoktur. Gereksiz tick\'leri kapatarak büyük performans kazancı sağlarsınız.`],
   ['Tick Kapatma',`Actor Details panelinde "Start with Tick Enabled" = False yapın. Blueprint\'te Disable Tick: Set Actor Tick Enabled (False). Sadece gerektiğinde Enable Tick yapın: örneğin bir trigger\'a girince tick başlat, çıkınca durdur. Bu yaklaşım idle actor\'lerin sıfır maliyetle durmasını sağlar.`],
   ['Timer Alternatifi',`Sürekli kontrol gereken mantığı Tick yerine Timer ile yapın. Set Timer by Function Name: her 0.5s veya 1s\'de bir çağırın. 60fps Tick yerine 2fps Timer = 30 kat performans kazancı. Mesafe kontrolü, AI algılama gibi işlemler Timer ile yapılabilir.`],
   ['Event-Driven Tasarım',`En iyi yaklaşım: Tick kullanmayın, event\'ler ile çalışın. Örnek: Health değişince → Event tetikle → UI güncelle (Tick\'te her frame kontrol yerine). Dispatchers, Interfaces ve BlueprintAssignable event\'ler kullanın. Bu prensip "don\'t poll, subscribe" olarak bilinir.`],
   ['Tick Grupları',`Kaçınılmaz tick kullanımında: Tick Group ayarlayın. Pre Physics, During Physics, Post Physics grupları. Actor sayısı çoksa Tick Interval ayarlayın: her frame yerine her 2-3 frame\'de bir (Tick Interval = 0.033 → 0.1). Uzaktaki actor\'lerin tick\'ini tamamen kapatın (distance-based tick).`]],
  [{t:'Tick Management',tags:[['fn','SetActorTickEnabled'],['fn','SetTimer']],
    d:'Tick optimizasyonu, timer ve event-driven tasarım.',
    f:cm('KÖTÜ: Her frame kontrol')+`\n  ${ev('Event Tick')}\n  └──→ ${nd('Branch')} (Health Changed?) → Update UI\n  ${cm('(Gereksiz 60 kontrol/saniye)')}\n\n${cm('İYİ: Event-driven')}\n  ${ev('On Health Changed (Dispatcher)')}\n  └──→ Update UI\n  ${cm('(Sadece değişince çalışır)')}\n\n${cm('Timer kullanımı:')}\n  ${ev('BeginPlay')}\n  └──→ ${nd('Set Timer')} 0.5s, CheckNearbyEnemies, Loop\n  ${cm('(Tick yerine saniyede 2 kontrol)')}\n\n${cm('Tick açma/kapama:')}\n  ${ev('On Enter Trigger')}\n  └──→ ${fn('Set Actor Tick Enabled')} True\n  ${ev('On Exit Trigger')}\n  └──→ ${fn('Set Actor Tick Enabled')} False`,
    v:['TickInterval: Float','bNeedsTick: Bool'],
    e:['Event Tick','Set Timer','Dispatchers']}],
  ['Profiler ile hangi actor\'lerin en çok tick maliyeti olduğunu bulun.','Yapay zeka tick\'lerini gruplandırın: her frame farklı AI grubu çalışsın.','Production build\'de Blueprint Nativization ile tick performansı iyileşir.'],
  ['Tick\'i tamamen kapatırsanız Timeline gibi tick-bağımlı sistemler de durur.','Timer ile çok sık çağrı yapmak (0.01s) tick\'ten farksız olur, mantıklı aralık seçin.'])},

// ====== LEVEL TASARIMI ======
{cat:'Level Tasarımı & Dünya',guide:g('bp-level-door-system','Kapı Sistemi (Detaylı)','Başlangıç',
  'Farklı tipte kapılar: itme, çekme, sürgü, otomatik, kilitli. Timeline animasyonu, ses efektleri ve kilit mekaniği.',
  [['Temel Kapı Actor',`BP_Door actor oluşturun. Static Mesh: kapı modeli. Door Frame (static, hareket etmez) ve Door Panel (hareketli parça). Door Panel ayrı bir Scene Component altında olmalı - pivot noktası menteşe pozisyonunda. Box Collision ile etkileşim alanı.`],
   ['Timeline ile Açma/Kapama',`OpenDoor Timeline: Float track 0→90 (derece), 1 saniye. Timeline\'ın Update\'inde Door Panel\'ın Relative Rotation Y değerini set edin. Play: kapı açılır, Reverse: kapı kapanır. bIsOpen Boolean ile durumu takip edin.`],
   ['Etkileşim',`BPI_Interactable interface ekleyin. Interact fonksiyonunda: bIsOpen kontrolü - açıksa kapat, kapalıysa aç. Prompt UI\'da "E ile Aç" veya "E ile Kapat" gösterin. Yaklaşım: Player trace hit → Does Implement Interface → Interact çağır.`],
   ['Kilit Mekaniği',`bIsLocked Boolean ve RequiredKeyID String ekleyin. Kilitli kapıyı açmaya çalışınca: oyuncunun envanterinde RequiredKeyID olan eşya var mı kontrol edin. Varsa: kilidi aç, anahtar sesi çal, sonra kapıyı aç. Yoksa: kilitli kapı sesi çal, "Kilitli" mesajı göster.`],
   ['Kapı Tipleri',`Enum ile DoorType: SingleSwing (tek yön), DoubleSwing (çift yön), Sliding (kayma), Automatic (yaklaşınca otomatik). Her tip için farklı Timeline ve animasyon. Otomatik kapı: Overlap trigger ile açılır, oyuncu ayrılınca kapanır. Sliding kapı: X ekseninde kayma Timeline\'ı.`]],
  [{t:'Door System',tags:[['fn','Timeline'],['class','Interface']],
    d:'Kapı açma/kapama, kilit ve farklı tipler.',
    f:ev('Interact (BPI_Interactable)')+`\n  │\n  ├──→ ${nd('Branch')} (bIsLocked)\n  │     │ True\n  │     ├──→ ${nd('Branch')} (Player Has Key?)\n  │     │     │ True\n  │     │     ├──→ ${fn('Remove Key')} from Inventory\n  │     │     ├──→ ${fn('Play Sound')} UnlockSFX\n  │     │     ├──→ bIsLocked = False\n  │     │     └──→ ${fn('Open Door')}\n  │     │     │ False\n  │     │     ├──→ ${fn('Play Sound')} LockedSFX\n  │     │     └──→ ${fn('Show Message')} "Kilitli"\n  │     │\n  │     │ False\n  │     └──→ ${nd('Branch')} (bIsOpen)\n  │           │ True → ${fn('Reverse Timeline')} (Close)\n  │           │ False → ${fn('Play Timeline')} (Open)\n\n${cm('Timeline: DoorOpen')}\n  0s → 0°\n  1s → 90°\n  Update: Door.RelativeRotation.Yaw = Value`,
    v:['bIsOpen: Bool','bIsLocked: Bool','RequiredKeyID: String','DoorType: Enum','OpenAngle: 90'],
    e:['Interact','Timeline Update','On Overlap (Automatic)']}],
  ['Kapı açma yönünü oyuncunun geldiği tarafa göre otomatik belirleyin (Dot Product ile).','Kapı sesleri (gıcırdama, kilit) ortamın gerçekçiliğini büyük ölçüde artırır.','Level Sequence ile sinematik kapı açılışları yapabilirsiniz (boss odası girişi).'],
  ['Kapı pivot noktası yanlışsa kapı merkezden döner, menteşe pozisyonunu doğru ayarlayın.','Otomatik kapıda overlap alanı çok büyükse uzaktan açılır, küçük tutun.'])},

// ====== MATERİAL ======
{cat:'Materyal & Shader',guide:g('bp-mat-dynamic-damage','Dinamik Hasar Materyali','Orta',
  'Vurulduğunda objenin yüzeyinde çatlak, yanık veya deformasyon efekti. Runtime\'da değişen materyal parametreleri.',
  [['Materyal Oluşturma',`M_DamageableSurface materyali oluşturun. BaseColor texture + DamageOverlay texture (çatlak/yanık paterni). Lerp node: Alpha = DamageAmount (Scalar Parameter, 0-1). DamageAmount 0 iken normal görünüm, 1 iken tamamen hasarlı. Emissive\'e kırmızı glow ekleyerek hasar bölgelerini vurgulayın.`],
   ['Dynamic Material Instance',`Blueprint\'te: BeginPlay\'da Create Dynamic Material Instance node ile mesh\'in materyalinden dinamik kopya oluşturun. Bu instance\'ı değişkende saklayın: DynMaterial (Material Instance Dynamic). Set Scalar Parameter Value ile DamageAmount parametresini runtime\'da değiştirebilirsiniz.`],
   ['Hasar Uygulama',`Event Any Damage\'da: hasar miktarına göre DamageAmount\'ı artırın. DamageAmount += Damage / MaxHealth. Clamp 0-1 arası. Set Scalar Parameter Value ile materyale aktarın. Böylece obje hasar aldıkça görsel olarak da bozulur.`],
   ['Lokasyon Bazlı Hasar',`Gelişmiş versiyon: vurulan noktada hasar efekti. Hit Location\'ı World Space\'ten Object Space\'e dönüştürün. Materyalde World Position + Sphere Mask ile vuruş noktasına yakın alanı etkileme. Birden fazla hit point desteklemek için Material Parameter Collection kullanın.`],
   ['Yıkılma Geçişi',`DamageAmount 1.0\'a ulaştığında objenin tamamen yıkılması: Geometry Collection ile kırılma, Dissolve efekti veya parça parça dökülme. Set Simulate Physics ile kırık parçalar dağılır. Kırılma anında ses ve partikül efekti.`]],
  [{t:'Dynamic Damage Material',tags:[['class','DynamicMaterialInstance'],['fn','SetScalarParameter']],
    d:'Runtime hasar görselleştirme.',
    f:ev('BeginPlay')+`\n  │\n  └──→ DynMat = ${fn('Create Dynamic Material Instance')} (Mesh.Material)\n        └──→ Mesh → ${fn('Set Material')} (0, DynMat)\n\n${ev('Event Any Damage')} (Amount)\n  │\n  ├──→ TotalDamage += Amount\n  ├──→ DamagePercent = TotalDamage / MaxHealth\n  ├──→ ${nd('Clamp')} (0, 1)\n  ├──→ DynMat → ${fn('Set Scalar Parameter')}\n  │     ("DamageAmount", DamagePercent)\n  │\n  └──→ ${nd('Branch')} (DamagePercent >= 1.0)\n        └──→ ${fn('Destroy with VFX')}\n              ├──→ ${fn('Spawn Emitter')} BreakVFX\n              ├──→ ${fn('Play Sound')} BreakSFX\n              └──→ ${fn('Destroy Actor')}`,
    v:['DynMat: Material Instance Dynamic','TotalDamage: Float','MaxHealth: Float','DamagePercent: Float'],
    e:['BeginPlay','Event Any Damage']}],
  ['Hasar texture\'ında alpha kanalı kullanarak çatlak desenlerinin şeklini kontrol edin.','Emissive hasar efekti yakın mesafede çok etkileyici görünür.','Bu sistemi araçlar, kapılar ve çevre objeleri için de kullanın.'],
  ['Dynamic Material Instance her actor için ayrı oluşturulmalı, shared material kullanmayın.','Çok fazla parameter güncellemesi performansı etkileyebilir, gerektiğinde güncelleyin.'])},

// ====== ANİMASYON ======
{cat:'Animasyon Temelleri',guide:g('bp-anim-blend-space','Blend Space Detaylı','Başlangıç',
  'Hız ve yön parametrelerine göre yürüme, koşma ve idle animasyonları arasında yumuşak geçiş. 1D ve 2D Blend Space oluşturma.',
  [['1D Blend Space',`Content Browser → Animation → Blend Space 1D. Skeleton seçin. Axis: Speed (0-600). Pozisyonları ekleyin: 0 = Idle, 200 = Walk, 400 = Jog, 600 = Run. Her pozisyona ilgili animasyonu sürükleyin. Preview\'da Axis değerini kaydırarak geçişi test edin. Smooth geçiş için Target Weight Interpolation Speed ayarlayın.`],
   ['2D Blend Space',`Blend Space (2D) oluşturun. X Axis: Direction (-180 ile 180), Y Axis: Speed (0-600). Grid\'e animasyonları yerleştirin: (0,0)=Idle, (0,300)=Walk_Forward, (0,600)=Run_Forward, (90,300)=Walk_Right, (-90,300)=Walk_Left, (180,300)=Walk_Back. Her yön ve hız kombinasyonu için animasyon.`],
   ['Anim Blueprint Bağlantısı',`Anim Blueprint\'te: Event Blueprint Update Animation\'da hız ve yön hesaplayın. Speed = CharacterMovement.Velocity.Length(). Direction = Calculate Direction (Velocity, ActorRotation). Bu değerleri değişkenlere kaydedin. AnimGraph\'ta Blend Space node ekleyin, Speed ve Direction pinlerini bağlayın.`],
   ['Pürüzsüz Geçiş',`Ani hareket değişikliklerinde animasyon sıçramasını önlemek için: FInterp To ile Speed ve Direction değerlerini yumuşatın. Interpolation hızı 10-15 ideal. Blend Space\'in Smoothing ayarlarını da kullanın: Damping Time = 0.1-0.2s.`],
   ['İleri Ayarlar',`Blend Space\'te "Interpolation" bölümünde: Interpolation Time, Target Weight Interpolation Speed per Bone, Max Blend Space. Per-Bone blending ile üst gövde ve alt gövde farklı blend yapabilir. Aimoffset ile kombine ederek koşarken nişan alma.`]],
  [{t:'Blend Space Setup',tags:[['class','BlendSpace'],['class','AnimBlueprint']],
    d:'1D ve 2D Blend Space oluşturma ve Anim BP bağlantısı.',
    f:cm('Anim Blueprint - Event Graph:')+`\n  ${ev('Event Blueprint Update Animation')}\n  │\n  ├──→ Velocity = ${fn('Get Velocity')}\n  ├──→ Speed = ${fn('Vector Length')} (Velocity)\n  ├──→ Direction = ${fn('Calculate Direction')}\n  │     (Velocity, ${fn('Get Actor Rotation')})\n  ├──→ SmoothedSpeed = ${fn('FInterpTo')}\n  │     (SmoothedSpeed, Speed, DT, 12)\n  └──→ SmoothedDir = ${fn('FInterpTo')}\n        (SmoothedDir, Direction, DT, 10)\n\n${cm('Anim Blueprint - AnimGraph:')}\n  ${nd('Output Pose')} ←── ${nd('Blend Space Player')}\n                         ├──→ BlendSpace: BS_Locomotion\n                         ├──→ X (Direction): SmoothedDir\n                         └──→ Y (Speed): SmoothedSpeed`,
    v:['Speed: Float','Direction: Float','SmoothedSpeed: Float','SmoothedDir: Float'],
    e:['Event Blueprint Update Animation']}],
  ['Walk ve Run animasyonlarının ayak döngüsünü senkronize edin (Sync Group).','Blend Space preview modunda eksen değerlerini slider ile test edin.','Farklı silah tipleri için ayrı Blend Space oluşturun (silahsız, tüfek, tabanca).'],
  ['Direction hesaplamasında düzgün -180/+180 geçişi sağlayın, aksi halde sıçrama olur.','Çok az animasyon ile Blend Space yapmak robotik görünür, en az 5-7 pozisyon kullanın.'])},

// ====== GÖREV (QUEST) ======
{cat:'Görev (Quest) Sistemi',guide:g('bp-quest-full','Tam Quest (Görev) Sistemi','İleri',
  'Ana görevler, yan görevler, görev zincirleri, hedef takibi, ödül sistemi ve görev UI. Veri tabanlı tasarım.',
  [['Veri Yapısı',`F_QuestData struct: QuestID (String), QuestName (String), Description (String), QuestType (Enum: Main/Side/Daily), Objectives (Array of F_QuestObjective), Rewards (Array of F_QuestReward), PrerequisiteQuests (Array of String), IsRepeatable (Bool). F_QuestObjective: Type (Enum: Kill/Collect/Talk/Reach/Interact), TargetID (String), RequiredCount (Int), CurrentCount (Int), Description (String).`],
   ['Quest Manager',`BP_QuestManager GameInstance veya subsystem olarak oluşturun. ActiveQuests (Map<String, F_QuestData>), CompletedQuests (Array of String). Fonksiyonlar: AcceptQuest, UpdateObjective, CompleteQuest, AbandonQuest. Her fonksiyon event dispatcher ile UI\'a bildirim gönderir.`],
   ['Hedef Takibi',`Farklı objective tipleri farklı şekilde güncellenir: Kill → düşman öldüğünde OnEnemyKilled event\'i kontrol. Collect → eşya alındığında kontrol. Talk → NPC ile konuşunca. Reach → belirli konuma ulaşınca (overlap trigger). Her objective tamamlanınca bir sonrakini aktif edin veya tüm objective\'ler tamamsa quest\'i bitirin.`],
   ['Ödül Sistemi',`F_QuestReward: Type (Enum: XP/Gold/Item/Skill), Amount (Int), ItemID (String). Quest tamamlanınca: her reward\'u sırayla uygulayın. XP → AddXP, Gold → AddGold, Item → AddToInventory. Ödül ekranı UI\'da gösterin: ne kazandığınızı listeleyin.`],
   ['Quest UI',`WBP_QuestTracker: Ekranın sağ üstünde aktif quest gösterimi. Quest adı, mevcut objective ve ilerleme (3/5 gibi). WBP_QuestLog: Tab ile açılan detaylı görev listesi. Ana/Yan görev filtreleme. Tamamlanmış görevleri gri göster. HUD\'da quest marker (3D dünyada hedef işareti).`]],
  [{t:'Quest System',tags:[['class','GameInstance'],['class','DataTable'],['fn','Dispatcher']],
    d:'Görev kabul, takip, tamamlama ve ödül.',
    f:fn('AcceptQuest')+` (QuestID)\n  │\n  ├──→ QuestData = ${fn('Get Data Table Row')} (QuestID)\n  ├──→ ${nd('Branch')} (Prerequisites met?)\n  │     │ True\n  │     ├──→ ActiveQuests.Add (QuestID, QuestData)\n  │     ├──→ ${fn('OnQuestAccepted Dispatcher')}\n  │     └──→ ${fn('Show Notification')} "Yeni Görev!"\n  │     │ False → ${cm('Ön koşullar sağlanmadı')}\n\n${fn('UpdateObjective')} (QuestID, ObjectiveIndex, Amount)\n  │\n  ├──→ Quest = ActiveQuests[QuestID]\n  ├──→ Obj = Quest.Objectives[Index]\n  ├──→ Obj.CurrentCount += Amount\n  ├──→ ${nd('Branch')} (Current >= Required)\n  │     ├──→ Obj.IsComplete = True\n  │     └──→ ${nd('Branch')} (All Objectives Complete?)\n  │           └──→ ${fn('CompleteQuest')} (QuestID)\n  └──→ ${fn('OnObjectiveUpdated Dispatcher')}\n\n${fn('CompleteQuest')} (QuestID)\n  ├──→ For Each Reward:\n  │     ├──→ XP: ${fn('AddXP')}\n  │     ├──→ Gold: ${fn('AddGold')}\n  │     └──→ Item: ${fn('AddItem')}\n  ├──→ CompletedQuests.Add (QuestID)\n  ├──→ ActiveQuests.Remove (QuestID)\n  └──→ ${fn('OnQuestCompleted Dispatcher')}`,
    v:['ActiveQuests: Map','CompletedQuests: Array','QuestDataTable: DataTable'],
    e:['AcceptQuest','UpdateObjective','CompleteQuest','OnQuestAccepted','OnQuestCompleted']}],
  ['Quest zincirleri için PrerequisiteQuests kullanın - önceki görev tamamlanmadan yenisi açılmaz.','Her quest için benzersiz ikon ve renk kodlaması kullanarak UI\'da kolay ayrım sağlayın.','Quest Tracker\'da sadece aktif görevin mevcut hedefini gösterin, kalabalık yapmayın.'],
  ['Quest verisini runtime\'da değiştirmeyin, Data Table\'ı template olarak kullanıp kopya üzerinde çalışın.','Çok fazla aktif quest performans sorunu yaratabilir, limit koyun (max 20).'])},

// ====== FİZİK ======
{cat:'Fizik Sistemi',guide:g('bp-physics-destructible','Yıkılabilir Obje Sistemi','Orta',
  'Chaos Destruction ile kırılan objeler. Hasar eşiği, kırılma paterni, fizik parçaları ve performans yönetimi.',
  [['Geometry Collection',`Static Mesh\'i Geometry Collection\'a dönüştürün: Mesh üzerine sağ tık → Create → Geometry Collection. Fracture Mode: Uniform Voronoi (düzgün parçalar), Clustered (gruplu), Radial (merkezi), Custom. Parça sayısı: 20-50 ideal (çok fazla = performans sorunu). Fracture Levels ile kademeli kırılma.`],
   ['Hasar Eşiği',`Geometry Collection Component\'ta Damage Threshold ayarlayın. Bu değerin altındaki hasar kırmaz. Threshold = 100 ise, 100+ hasar geldiğinde kırılır. Event: On Chaos Break event ile kırılma anını yakalayın. Apply Damage node ile hasar verin.`],
   ['Kırılma Davranışı',`Damage Model: Internal Strain (iç gerilim) veya External (dış kuvvet). Internal: yapısal bütünlük, hasar birikimi ile kırılma. External: anlık hasar yeterli ise kırılma. Kırılan parçalar fizik simülasyonu ile dağılır. Sleep ayarı ile duran parçaları uyutun (performans).`],
   ['Kırılma Efektleri',`On Chaos Break event\'inde: partikül spawn (toz bulutu, kıymık), ses efekti (kırılma/çatlama), Camera Shake (yakınsa). Decal: yerde çatlak veya hasar izi. Kırık parçalar belirli süre sonra Fade Out ile kaybolsun (SetLifespan veya Timeline ile alpha).`],
   ['Performans',`Kırık parça sayısını sınırlayın: Max Cluster Level. Uzaktaki objelerde destruction kapatın. Sleep ayarları: hareket etmeyen parçaları hemen uyutun. Debris Lifetime: kırıntılar 5-10s sonra yok olsun. Level\'da toplam aktif destruction obje sayısını sınırlayın.`]],
  [{t:'Chaos Destruction',tags:[['class','GeometryCollection'],['fn','ApplyDamage']],
    d:'Kırılabilir obje, hasar eşiği ve efektler.',
    f:ev('Event Any Damage')+` (Amount)\n  │\n  ├──→ AccumulatedDamage += Amount\n  └──→ ${nd('Branch')} (AccumulatedDamage >= DamageThreshold)\n        │ True\n        ├──→ ${fn('Set Simulate Physics')} (GC, True)\n        ├──→ ${fn('Apply Radial Force')}\n        │     ├──→ Origin: DamageOrigin\n        │     ├──→ Radius: 200\n        │     └──→ Strength: 50000\n        ├──→ ${fn('Spawn Emitter')} DebrisVFX\n        ├──→ ${fn('Play Sound')} BreakSFX\n        ├──→ ${fn('Camera Shake')} BreakShake\n        └──→ ${nd('Set Timer')} 10s → ${fn('Fade and Destroy')}\n\n${fn('Fade and Destroy')}\n  ├──→ ${fn('Play Timeline')} FadeOut (1s)\n  │     └──→ Set All Materials Opacity → 0\n  └──→ ${fn('Destroy Actor')}`,
    v:['DamageThreshold: 100','AccumulatedDamage: Float','DebrisLifetime: 10s'],
    e:['Event Any Damage','On Chaos Break']}],
  ['Kademeli kırılma (2 Fracture Level) büyük objelerde daha etkileyici görünür.','Kırılma noktasında Radial Force ile parçaları dışarı fırlatın.','Destruction\'ı önceden hesaplatın (Cook time), runtime\'da hesaplama pahalıdır.'],
  ['Çok fazla parça physics simülasyonu çökmelere yol açabilir, 50\'den az tutun.','Geometry Collection\'ın collision\'ını kontrol edin, oyuncu parçalara takılmasın.'])},

// Daha fazla detaylı rehber
{cat:'Crafting & Üretim',guide:g('bp-craft-full','Tam Crafting (Üretim) Sistemi','Orta',
  'Malzeme toplama, tarif öğrenme, üretim süreci, başarı/başarısızlık oranı ve UI. Hayatta kalma ve RPG oyunları için.',
  [['Tarif Veri Yapısı',`F_CraftRecipe struct: RecipeID, RecipeName, Description, Category (Enum: Weapon/Armor/Potion/Food/Tool), RequiredMaterials (Array of F_CraftMaterial: ItemID + Quantity), ResultItemID, ResultQuantity, CraftTime (Float), RequiredLevel (Int), SuccessRate (Float 0-1). Data Table ile tüm tarifleri tanımlayın.`],
   ['Tarif Öğrenme',`Oyuncu başlangıçta tüm tarifleri bilmez. KnownRecipes array. Tarif öğrenme yolları: seviye atlama ile otomatik, tarif kitabı bulma (pickup), NPC\'den satın alma, belirli görev tamamlama. Her yeni tarif öğrenildiğinde bildirim gösterin.`],
   ['Üretim Süreci',`TryCraft fonksiyonu: 1) Tarif bilinir mi? 2) Yeterli seviye mi? 3) Malzemeler yeterli mi? Tüm kontroller geçerse: malzemeleri envanterden çıkar, CraftTime kadar bekleme başlat (progress bar), süre bitince SuccessRate ile kontrol (Random Float), başarılı ise sonucu envantere ekle, başarısız ise malzemelerin %50\'sini geri ver.`],
   ['Craft İstasyonu',`BP_CraftStation actor: belirli kategorideki tarifleri craft etme. Blacksmith (silah/zırh), Alchemy Table (iksir), Cooking Station (yemek). Oyuncu yaklaşıp interact edince craft UI açılır. İstasyon tipi ile filtreleme: sadece ilgili tarifler gösterilir.`],
   ['Craft UI',`Sol panel: bilinen tarifleri listele (isim + ikon + gerekli malzemeler). Sağ panel: seçili tarifin detayı (sonuç eşya, malzemeler renk kodlu: yeşil=yeterli/kırmızı=yetersiz, craft butonu). Alt panel: craft progress bar ve sonuç bildirimi. Filtre: kategori ve arama.`]],
  [{t:'Crafting System',tags:[['class','DataTable'],['fn','RemoveItem'],['fn','AddItem']],
    d:'Tarif sistemi, malzeme kontrolü, üretim süreci.',
    f:fn('TryCraft')+` (RecipeID)\n  │\n  ├──→ Recipe = ${fn('Get Data Table Row')} RecipeID\n  ├──→ ${nd('Branch')} (KnownRecipes.Contains(RecipeID))\n  │     │ False → ${cm('Tarif bilinmiyor')}\n  ├──→ ${nd('Branch')} (PlayerLevel >= Recipe.RequiredLevel)\n  │     │ False → ${cm('Seviye yetersiz')}\n  ├──→ For Each Recipe.RequiredMaterials:\n  │     └──→ ${nd('Branch')} HasItem(Mat.ItemID, Mat.Qty)\n  │           │ False → ${fn('Show Error')} "Yetersiz malzeme"\n  │\n  ├──→ ${cm('Tüm kontroller geçti')}\n  ├──→ For Each Material: ${fn('Remove Item')}\n  ├──→ Start Craft Timer (Recipe.CraftTime)\n  │     └──→ Show Progress Bar\n  │\n  └──→ ${ev('On Craft Timer Complete')}\n        ├──→ Roll = ${nd('Random Float')} (0, 1)\n        ├──→ ${nd('Branch')} (Roll <= SuccessRate)\n        │     │ True\n        │     ├──→ ${fn('Add Item')} (ResultID, ResultQty)\n        │     ├──→ ${fn('Play Sound')} CraftSuccess\n        │     └──→ ${fn('Show Result')} "Başarılı!"\n        │     │ False\n        │     ├──→ Refund 50% Materials\n        │     └──→ ${fn('Show Result')} "Başarısız!"`,
    v:['KnownRecipes: Array','CraftDataTable: DataTable','bIsCrafting: Bool'],
    e:['TryCraft','On Craft Complete','OnRecipeLearned']}],
  ['Craft sırasında eşya tooltip\'ında stat karşılaştırması gösterin (mevcut vs yeni).','Nadir malzemelerin craft\'ta başarı oranını artırması gibi mekanikler ekleyin.','Craft sesi ve görsel efekti (duman, kıvılcım) ortam hissini güçlendirir.'],
  ['Craft sırasında envanterden malzeme çıkarmadan önce son kontrol yapın.','SuccessRate çok düşük olursa oyuncu frustrasyona girer, %80+ önerilir.'])},

{cat:'Multiplayer & Network',guide:g('bp-mp-lobby','Multiplayer Lobi Sistemi','İleri',
  'Oyuncuların toplanıp oyun başlangıcını beklediği lobi. Oyuncu listesi, hazır durumu, host ayarları ve oyun başlatma.',
  [['Session Oluşturma',`Host oyuncu: Create Session node ile session oluşturur. Session Settings: MaxPlayers, bIsLANMatch, bUsesPresence, MapName, GameMode. Advanced Session plugin ile Steam/EOS entegrasyonu. Session başarıyla oluşturulunca Lobby level\'a geçiş yapın.`],
   ['Session Bulma ve Katılma',`Client: Find Sessions node ile mevcut session\'ları arayın. Sonuçları listeleyin: session name, player count, ping. Seçili session\'a Join Session ile katılın. Başarılı katılımda Lobby level\'a travel edin. Bağlantı kopmasına karşı timeout ve retry ekleyin.`],
   ['Lobi UI',`WBP_Lobby: Oyuncu listesi (PlayerState\'ten isim ve hazır durumu), harita seçimi (host), oyun modu seçimi, chat kutusu, "Hazır" butonu, "Oyunu Başlat" butonu (sadece host\'a görünür). PlayerState\'e bIsReady Boolean ekleyin, Replicated yapın.`],
   ['Hazır Sistemi',`Her oyuncu "Hazır" butonuna basınca kendi PlayerState.bIsReady = True yapar (Server RPC ile). Tüm oyuncular hazır olunca host "Oyunu Başlat" butonunu aktif eder. Oyun başlatma: Server Travel ile oyun map\'ine geçiş. Tüm client\'lar otomatik takip eder.`],
   ['Hata Yönetimi',`Oyuncu lobi\'den ayrılırsa: Destroy Session callback, diğer oyunculara bildirim. Host ayrılırsa: session kapanır, tüm client\'lar ana menüye döner. Bağlantı hatası: timeout sonrası ana menüye yönlendir. Session dolu mesajı: MaxPlayers aşıldığında.`]],
  null,
  ['Session arama filtreleri ekleyin: harita, mod, ping limiti.','Lobi\'de countdown timer kullanarak herkesin hazır olmasını bekleyin.','Karakter seçimi/özelleştirme lobi\'de yapılabilir.'],
  ['Server Travel sorunlarında tüm oyuncular düşebilir, error handling ekleyin.','Session ayarlarını test için LAN ile başlayın, sonra online\'a geçin.'])},

{cat:'Sinematik & Sekanslar',guide:g('bp-cinematic-intro','Sinematik Giriş Sahnesi','Orta',
  'Level başlangıcında kamera hareketi ile sahne tanıtımı. Level Sequence ile sinematik kontrol.',
  [['Level Sequence',`Level Sequence actor oluşturun: Cinematics → Level Sequence. Sequencer editörü açılır. Camera Cut track ile kamera geçişleri ekleyin. Birden fazla Cine Camera Actor kullanarak farklı açılar oluşturun. Her kameranın FOV, pozisyon ve rotasyon animasyonunu keyframe ile ayarlayın.`],
   ['Kamera Hareketleri',`İlk kamera: panoramik sahne görünümü (yavaş pan). İkinci kamera: önemli bir noktaya zoom (boss kapısı, hedef). Üçüncü kamera: oyuncunun arkasına yaklaşım. Smooth hareket için Cubic interpolation kullanın. Her kamera arası geçiş süresi 2-3s. Toplam intro 10-15s ideal.`],
   ['UI Overlay',`Sinematik sırasında: üst ve alt siyah bar ekleyin (sinema formatı). Oyuncu input\'unu devre dışı bırakın. Altyazı veya konum ismi gösterin ("Kayıp Tapınak" gibi). Fade in ile başlayın, fade out ile oyuncuya kontrolü verin.`],
   ['Blueprint Tetikleme',`BeginPlay\'da Level Sequence\'ı otomatik başlatın: Get Level Sequence Actor → Play. Sequence bittiğinde: On Sequence Finished event → oyuncu kontrolünü etkinleştirin, sinema barlarını kaldırın, HUD\'ı gösterin. Skip butonu: herhangi bir tuş ile atlama imkanı.`],
   ['Ses ve Müzik',`Sequence içinde Audio Track ekleyin: epik giriş müziği, ortam sesleri (rüzgar, su sesi). Fade In ile müzik başlasın. Sequence bitince oyun müziğine crossfade yapın. Ses efektleri kamera hareketine senkron olsun (yaklaşırken ses artar).`]],
  [{t:'Cinematic Intro',tags:[['class','LevelSequence'],['fn','Play']],
    d:'Level Sequence ile sinematik giriş.',
    f:ev('BeginPlay')+`\n  │\n  ├──→ ${fn('Disable Input')} (PlayerController)\n  ├──→ ${fn('Show Cinema Bars')} (Anim: SlideIn)\n  ├──→ ${fn('Fade From Black')} (1s)\n  │\n  ├──→ SequenceActor → ${fn('Play')}\n  │     ${cm('Kamera 1: Panoramik (0-4s)')}\n  │     ${cm('Kamera 2: Zoom hedef (4-8s)')}\n  │     ${cm('Kamera 3: Oyuncu arkası (8-12s)')}\n  │\n  └──→ ${ev('On Sequence Finished')}\n        ├──→ ${fn('Enable Input')}\n        ├──→ ${fn('Hide Cinema Bars')} (Anim: SlideOut)\n        ├──→ ${fn('Show HUD')}\n        └──→ ${fn('Crossfade Music')} IntroMusic → GameMusic\n\n${ev('Any Key Press (During Sequence)')}\n  └──→ ${fn('Skip Sequence')}\n        ├──→ SequenceActor → ${fn('Stop')}\n        └──→ Jump to → On Sequence Finished`,
    v:['CinematicSequence: LevelSequence','bIsInCinematic: Bool'],
    e:['BeginPlay','On Sequence Finished','Any Key (Skip)']}],
  ['Skip butonu eklemek oyuncuya saygıdır, özellikle tekrar oynamalarda.','Sinematik kalitesini artırmak için Depth of Field ve Motion Blur kullanın.','Her level için benzersiz intro yaparak sahne hafızası oluşturun.'],
  ['Sinematik sırasında oyuncu\'nun fizik etkileşimini kapatın, aksi halde saçma durumlar oluşur.','Sequence bittiğinde kameranın oyuncu kamerasına yumuşak geçişini sağlayın, ani geçiş rahatsız eder.'])},

{cat:'Etkileşim Sistemi',guide:g('bp-interact-highlight','Etkileşim Vurgulama Sistemi','Başlangıç',
  'Oyuncunun bakabileceği etkileşilebilir objeleri vurgulama. Outline, glow veya renk değişimi ile görsel geri bildirim.',
  [['Trace ile Algılama',`Tick veya Timer ile kameradan ileri doğru Line Trace atın. Trace mesafesi: InteractRange (300). Hit edilen actor\'ün BPI_Interactable interface\'ini implement edip etmediğini kontrol edin. Implement ediyorsa: bu actor etkileşilebilir.`],
   ['Vurgulama',`Etkileşilebilir actor bulunduğunda: Actor\'ün mesh\'ine Custom Depth Stencil uygulayın (Set Render Custom Depth Pass = True, Custom Depth Stencil Value = 1). Post Process Material ile outline çizin. Alternatif: mesh\'in materyalindeki Emissive parametresini artırarak glow efekti.`],
   ['Vurgu Kaldırma',`Her frame: önceki vurgulanan actor\'den vurguyu kaldırın (Custom Depth False), yeni actor\'e vurgulayın. Önceki ve şu anki etkileşim actor\'ünü karşılaştırın - farklıysa eski olanı temizleyin. Actor yoksa (trace miss) tüm vurguları kaldırın.`],
   ['Etkileşim UI',`Vurgulanan objenin üzerinde veya ekranın ortasında: "E ile Etkileş" prompt UI. Obje tipine göre farklı metin: "E ile Aç", "E ile Topla", "E ile Konuş". BPI_Interactable interface\'ine GetInteractText fonksiyonu ekleyerek her actor kendi metnini döndürsün.`],
   ['Performans',`Trace\'i her frame yerine Timer ile yapın (0.1s aralık yeterli). Trace channel özelleştirin: sadece etkileşilebilir objeleri kontrol eden InteractChannel oluşturun. Visibility kontrolü: obje kameranın görüş alanında mı (ekstra optimizasyon).`]],
  [{t:'Interaction Highlight',tags:[['fn','LineTrace'],['fn','SetCustomDepth'],['class','Interface']],
    d:'Trace ile algılama, outline ve etkileşim UI.',
    f:ev('Timer (0.1s Loop)')+`\n  │\n  ├──→ ${fn('Line Trace')} (Camera Forward, 300 units)\n  ├──→ ${nd('Branch')} (Hit + Implements BPI_Interactable?)\n  │     │ True\n  │     ├──→ NewTarget = HitActor\n  │     ├──→ ${nd('Branch')} (NewTarget != OldTarget)\n  │     │     │ True\n  │     │     ├──→ OldTarget: ${fn('Set Custom Depth')} False\n  │     │     └──→ NewTarget: ${fn('Set Custom Depth')} True\n  │     ├──→ OldTarget = NewTarget\n  │     ├──→ InteractText = ${fn('GetInteractText')} (NewTarget)\n  │     └──→ ${fn('Show Prompt')} (InteractText)\n  │     │ False\n  │     ├──→ OldTarget: ${fn('Set Custom Depth')} False\n  │     ├──→ OldTarget = null\n  │     └──→ ${fn('Hide Prompt')}\n\n${ev('IA_Interact Started')}\n  └──→ ${nd('Branch')} (CurrentTarget valid?)\n        └──→ CurrentTarget → ${fn('Interact')} (PlayerRef)`,
    v:['CurrentTarget: Actor','InteractRange: 300','InteractChannel: ECC_GameTraceChannel1'],
    e:['Timer 0.1s','IA_Interact Started']}],
  ['Outline kalınlığını ve rengini eşya nadirliğine göre değiştirin (beyaz, yeşil, mavi, mor).','Etkileşim menzilini oyun tipine göre ayarlayın - FPS\'te kısa, TPS\'te orta.','Controller kullanıcıları için auto-target (en yakın etkileşilebilir) ekleyin.'],
  ['Custom Depth tüm mesh\'i etkiler, seçici olmanız gerekirse ayrı mesh component kullanın.','Çok sayıda etkileşilebilir objede trace performansını izleyin.'])},
];

// ===== MERGE =====
const data = [...guideData];
let added = 0;
for (const entry of batch) {
  const cat = data.find(c => c.category === entry.cat);
  if (cat) { cat.guides.push(entry.guide); added++; }
  else { console.log('NOT FOUND:', entry.cat); }
}

console.log('New guides added:', added);
let total = 0;
data.forEach(c => total += c.guides.length);
console.log('Total categories:', data.length);
console.log('Total guides:', total);

function sv(val,indent=0){const pad=' '.repeat(indent);if(val===null||val===undefined)return'null';if(typeof val==='string')return"'"+esc(val)+"'";if(typeof val==='number'||typeof val==='boolean')return String(val);if(Array.isArray(val)){if(val.length===0)return'[]';const items=val.map(v=>sv(v,indent+4));if(JSON.stringify(val).length<80&&!val.some(v=>typeof v==='object'))return'['+items.join(', ')+']';return'[\n'+items.map(i=>pad+'    '+i).join(',\n')+'\n'+pad+']';}if(typeof val==='object'){const entries=Object.entries(val);if(entries.length===0)return'{}';const parts=entries.map(([k,v])=>k+': '+sv(v,indent+4));if(JSON.stringify(val).length<100)return'{ '+parts.join(', ')+' }';return'{\n'+parts.map(p=>pad+'    '+p).join(',\n')+'\n'+pad+'}';}return String(val);}

let output='export const guideData = [\n';data.forEach((cat,ci)=>{output+='    {\n';output+="        category: '"+esc(cat.category)+"',\n";if(cat.icon)output+="        icon: '"+esc(cat.icon)+"',\n";output+='        guides: [\n';cat.guides.forEach((g2,gi)=>{output+='            '+sv(g2,12);if(gi<cat.guides.length-1)output+=',';output+='\n';});output+='        ]\n    }';if(ci<data.length-1)output+=',';output+='\n';});output+='];\n';

fs.writeFileSync('src/guideData.js',output,'utf-8');
console.log('File written successfully.');
